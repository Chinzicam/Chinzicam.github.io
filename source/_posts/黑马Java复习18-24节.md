---
title:  JavaSE每日复习18-24节（黑马资源
author: 橙子草草
date: 2022-10-06 13:50:40
tags:
- java
- 复习
categories: 
- java笔记
cover: true
sidebar: [blogger, category, toc] ## 放置任何你想要显示的侧边栏部件
---

## day18早上复习

### 1、单例设计模式

（1）饿汉式：在类初始化时就直接创建对象

```java
（1）像早期的枚举类
public class Single{
    public static final Single INSTANCE = new Single();
    private Single(){}
}
（2)借用后期的枚举类
 public enum Single{
    INSTANCE
}   
（3）对（1）种的改装，外观看起来像懒汉式，本质上是饿汉式
public class Single{
    private static final Single INSTANCE = new Single();
    private Single(){}
    public static Single getInstance(){
        return INSTANCE;
    }
}    
```

（2）懒汉式：在调用获取单例对象的方法时，才创建对象

```java
（1）同步方法式
public class Single{
    private static Single instance;
    private Single(){}
    public static synchronized Single getInstance(){
        if(instance == null){
            instance = new Single();
        }
        return instance;
    }
}  
（2）内部类式
public class Single{
    private Single(){}
    private static class Inner{
        private static Single instance = new Single();//在内部类初始化时创建外部类的单例对象
    }
    public static Single getInstance(){
        return Inner.instance;//在调用这个方法时，使用内部类，才会让内部类进行初始化
    }
}
```

### 2、线程的生命周期

（1）JDK1.5之前

简单来说，线程的生命周期有五种状态：新建（New）、就绪（Runnable）、运行（Running）、阻塞（Blocked）、死亡（Dead）。CPU需要在多条线程之间切换，于是线程状态会多次在运行、阻塞、就绪之间切换。

![image-20210829150633574](每日早上复习.assets/image-20210829150633574.png)



（2）JDK1.5之后

在java.lang.Thread.State的枚举类中这样定义：

```java
    public enum State {
        NEW,
        RUNNABLE,
        BLOCKED,
        WAITING,
        TIMED_WAITING,
        TERMINATED;
    }
```

首先它没有区分：就绪和运行状态，因为对于Java对象来说，只能标记为可运行，至于什么时候运行，不是JVM来控制的了，是OS来进行调度的，而且时间非常短暂，因此对于Java对象的状态来说，无法区分。只能我们人为的进行想象和理解。

其次根据Thread.State的定义，阻塞状态是分为三种的：BLOCKED、WAITING、TIMED_WAITING。

![image-20210829150651198](每日早上复习.assets/image-20210829150651198.png)

### 3、常用API

（1）数学相关类

```java
java.lang.Math类：各种数学计算的方法
java.math包：BigInteger,BigDecimal
java.util.Random类：产生各种类型的随机值
```

（2）日期时间API

```java
第一代：
    java.util.Date：日期时间表示类
    java.text.SimpleDateFormat：把日期时间转为想要的格式的字符串，或者也可以把某种格式的字符串转为日期时间对象
第二代：
    java.util.Calendar：日历
    java.util.TimeZone：表示时区
第三代：JDK1.8引入
    java.time.LocalDate、LocalTime、LocalDateTime
    java.time.ZoneDateTime
    java.time.Period日期间隔、java.time.Duration时间间隔
    java.time.format.DateTimeFormatter 
```



（3）系统类

```java
java.lang.System：系统类
java.lang.Runtime：JVM运行环境类
```



（4）数组工具类

```java
java.util.Arrays
```



（5）字符串相关

```java
java.lang.String
```

（6）字符串比较工具类

```java
java.text.Collator
```





### 4、String类的特点和API

（1）String类本身是final修饰，它不能被继承

（2）String类的对象也是不可变对象，因为不可变，意味着字符串常量对象是可以共享的。

（3）String类的内部类使用什么来表示一串字符

JDK1.9之前：private final char[] value;

JDK1.9之后：private final byte[] value;

（4）字符串的拼接

```java
(1)+拼接，任意类型的数据（包括基本数据类型和引用数据）与字符串类型的变量或常量进行拼接，结果都是字符串。
    	如果是引用数据类型，拼接时，会自动调用对象的toString方法。
（2）concat(值)：调用String类对象的concat拼接
    
    +：如果是两个常量池中的字符串常量+，结果还是在常量池
    concat：无论是那种情况的两个字符串拼接，结果都是在堆。除了调用concat之后又调用intern()    
```

（5）字符串对象的创建

```java
（1）直接""，它是在常量池，可能会出现共享的情况，如果和常量池中的另一个字符串内容相同，就会共享。
（2）构造器，会在堆中new一个，如果()中还有""，还会引用常量池中内容
（3）String类的valueOf()，和构造器一样
（4）任意引用数据类型的对象调用toString()
```

（6）空字符串

```java
空字符串是指，一个字符串对象，但是它的长度为0，没有任意字符。不能是null，不能是未初始化。
空字符的判断：
    假设String类型的变量是str
    "".equals(str)
    str!=null && str.equals("")
    str!=null && str.isEmpty()
    str!=null && str.length()==0
```

（7）字符串的比较

```java
（1）==：比较两个字符串的地址，只有都是字符串常量池中两个字符串==，比较结果才会true
（2）equals
    严格区分大小写：boolean equals(Object obj)
    不区分大小写：boolean equalsIgnoreCase(String anotherString) 
（3）compare
    严格区分大小写：int compareTo（String str）：按照字符的Unicode值
    不区分大小写：int compareToIgnoreCase(String str) 
（4）定制比较大小
    java.text.Collator里面的compare方法
    或者是自定义类实现Comparator接口，自己写的比较规则
```

## day19早上复习

### 1、String类常用的API

（1）boolean isEmpty()：字符串是否为空

（2）int length()：返回字符串的长度

（3）String concat(xx)：拼接，运行效果等价于+

（4）boolean equals(Object obj)：比较字符串是否相等，区分大小写

（5）boolean equalsIgnoreCase(Object obj)：比较字符串是否相等，不区分大小写

（6）int compareTo(String other)：比较字符串大小，区分大小写，按照Unicode编码值比较大小

（7）int compareToIgnoreCase(String other)：比较字符串大小，不区分大小写

（8）String toLowerCase()：将字符串中大写字母转为小写

（9）String toUpperCase()：将字符串中小写字母转为大写

（10）String trim()：去掉字符串前后空白符

（11）public String intern()：结果在常量池中共享

（12）boolean contains(xx)：是否包含xx

（13）int indexOf(xx)：从前往后找当前字符串中xx，即如果有返回第一次出现的下标，要是没有返回-1

（14）int lastIndexOf(xx)：从后往前找当前字符串中xx，即如果有返回最后一次出现的下标，要是没有返回-1

（15）String substring(int beginIndex) ：返回一个新的字符串，它是此字符串的从beginIndex开始截取到最后的一个子字符串。 

（16）String substring(int beginIndex, int endIndex) ：返回一个新字符串，它是此字符串从beginIndex开始截取到endIndex(不包含)的一个子字符串。 

（17）char charAt(index)：返回[index]位置的字符

（18）char[] toCharArray()： 将此字符串转换为一个新的字符数组返回

（19）String(char[] value)：返回指定数组中表示该字符序列的 String。 

（20）String(char[] value, int offset, int count)：返回指定数组中表示该字符序列的 String。

（21）static String copyValueOf(char[] data)： 返回指定数组中表示该字符序列的 String

（22）static String copyValueOf(char[] data, int offset, int count)：返回指定数组中表示该字符序列的 String

（23）static String valueOf(char[] data, int offset, int count) ： 返回指定数组中表示该字符序列的 String

（24）static String valueOf(char[] data)  ：返回指定数组中表示该字符序列的 String

（25）byte[] getBytes()：编码，把字符串变为字节数组，按照平台默认的字符编码方式进行编码

	        byte[] getBytes(字符编码方式)：按照指定的编码方式进行编码

（26）new String(byte[] ) 或 new String(byte[], int, int)：解码，按照平台默认的字符编码进行解码

           new String(byte[]，字符编码方式 ) 或 new String(byte[], int, int，字符编码方式)：解码，按照指定的编码方式进行解码

（27）boolean startsWith(xx)：是否以xx开头

（28）boolean endsWith(xx)：是否以xx结尾

（29）boolean matchs(正则表达式)：判断当前字符串是否匹配某个正则表达式。

（30）String replace(被替换字符 ,  替换后的字符)：不支持正则

（31）String replaceFirst(正则，value)：替换第一个匹配部分，当前字符串中第一个匹配正则的部分会被替换为value

（32）String repalceAll(正则， value)：替换所有匹配部分，当前字符串中所有匹配正则的部分会被替换为value

（33）String[] split(正则)：按照某种规则进行拆分



### 2、StringBuffer和StringBuilder常用API

常用的API，StringBuilder、StringBuffer的API是完全一致的

（1）StringBuffer append(xx)：拼接，追加

（2）StringBuffer insert(int index, xx)：在[index]位置插入xx

（3）StringBuffer delete(int start, int end)：删除[start,end)之间字符

StringBuffer deleteCharAt(int index)：删除[index]位置字符

（4）void setCharAt(int index, xx)：替换[index]位置字符

（5）StringBuffer reverse()：反转

（6）void setLength(int newLength) ：设置当前字符序列长度为newLength

（7）StringBuffer replace(int start, int end, String str)：替换[start,end)范围的字符序列为str

（8）int indexOf(String str)：在当前字符序列中查询str的第一次出现下标

          int indexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的第一次出现下标
    
         int lastIndexOf(String str)：在当前字符序列中查询str的最后一次出现下标
    
         int lastIndexOf(String str, int fromIndex)：在当前字符序列[fromIndex,最后]中查询str的最后一次出现下标

（9）String substring(int start)：截取当前字符序列[start,最后]

（10）String substring(int start, int end)：截取当前字符序列[start,end)

（11）String toString()：返回此序列中数据的字符串表示形式





### 3、Collection接口常用API

（1）添加

void add(元素)：添加一个元素

void addAll(另一个Collection集合)：一次添加多个元素，把另一个Collection集合的元素都添加到当前集合中。

（2）删除

remove(元素)：直接删除某个元素。目标对象与集合中的某个元素equals返回true时，就是被删除目标。

removeAll（另一个Collection集合）：从当前集合中删除多个元素，即当前集合和另一个集合的“相同”元素就会被删除。

retainAll(另一个Collection集合)：从当前集合中删除多个元素，即当前集合和另一个集合的“不相同”元素就会被删除。

removeIf(Predicate p)：根据条件删除元素。如果集合中的元素满足Predicate 接口的test方法指定的判断条件时，就会被删除。

clear()：清空集合中的所有元素。

（3）查找

boolean contains（元素）：判断是否包含某个元素。

boolean containsAll（另一个Collection集合）:判断另一个集合是否是当前集合的“子集”，即另一个集合的所有元素在当前集合中都能被找到。

int size()：返回所有元素的个数

Object[] toArray()：把所有元素放到一个Object[]中返回。



### 4、Iterable接口和Iterator接口

Collection接口是继承java.lang.Iterable接口，意味着Collection系列的集合都支持foreach循环遍历。

java.lang.Iterable接口依赖于java.util.Iterator接口，foreach循环本质还是用Iterator进行遍历。

当然也可以直接使用Iterator迭代器对Collection集合进行遍历。

boolean hasNext()：判断迭代器当前位置是否有元素可取，如果有就返回true，否则就返回false

Object next()：取出迭代器当前位置的元素，并且迭代器要往后移动。

void remove()：删除迭代器刚刚取出来的元素。

说明：一次hasNext()，对应一次next()，一次next()最多只能对应一次remove()

```java
package com.atguigu.collection;

import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;

public class TestIterator {
    public static void main(String[] args) {
        Collection coll = new ArrayList();
        coll.add("hello");
        coll.add("world");
        coll.add("java");
        coll.add("h5");

        Iterator iterator = coll.iterator();
        /*while (iterator.hasNext()) {
            if(((String)iterator.next()).length()>0){
                System.out.println(iterator.next());
            }

        }*/
        while (iterator.hasNext()) {
           String str =  (String)iterator.next();
            if(str.length()>0){
                System.out.println(str);
            }

        }
    }
}
```



### 5、Collection系列集合元素的遍历和删除

（1）foreach循环中不能删除、添加元素，即不能出现修改元素个数的代码

（2）Iterator迭代器遍历集合中，可以删除元素，但是调用迭代器自己的remove方法，不能调用集合的remove方法。添加类似。

（3）每一次使用Iterator迭代器遍历集合，都要重新调用iterator()方法获取最新的迭代器对象。（目的是让游标回到最初的位置，而且要让expectedModCount和modCount一致。

## day20早上复习

### 1、泛型方法

（1）什么情况下需要使用泛型方法？

当某个方法在设计时，它的形参、返回值类型不确定时，需要调用时才能确定，可以使用泛型方法。

- 泛型方法可以是静态方法，也可以是非静态方法。
- 每一个泛型方法声明的<T>泛型都是独立的，和其他方法无关。
- 方法在调用时，会根据实参的类型自动推断<T>的具体类型

例如：编写一个复制任意类型的对象数组的方法，如果不使用泛型，那么就只能使用Object[]

```java
public class MyArrays{
    /*public static Object[] copyOf(Object[] arr, int newLength){
        //....
    }*/
    public static <T> T[] copyOf(T[] arr, int newLength){
        //...
        return null;
    }
    
    public static <T> void method(T t){
        //...
    }
}
```

```java
public class TestMyArrays{
    public static void main(String[] args){
        String[] strings = {"hello","world","java"};
       // Object[] newArr = MyArrays.copyOf(strings, 5);
        String[] newArr = MyArrays.copyOf(strings, 5);
    }
}
```



（2）泛型方法的格式

```java
【修饰符】 <T> 返回值类型 方法名(【形参列表】)【throws 异常列表】{
    
}
```



### 2、泛型类与泛型接口

（1）什么情况下使用泛型类与泛型接口呢？

- 当类中的某个实例变量的类型不确定时，可以考虑在类的上面声明泛型来表示这个未知的类型

```java
public class Student<T>{
    private String name;
    private T score;
}
```

- 当类或接口中的某个（某些）“非静态方法”的形参或返回值类型不确定时，也可以考虑在类或接口的上面声明泛型来表示这个未知的类型。如果是多个方法都使用了类或接口上面声明的泛型，那么它们的类型是一致的。

```java
public class MyClass<T>{
    public void method(T t){
        
    }
    public void fun(T t){
        
    }
    //这两个方法的T是一致，不是独立的
}
```

（2）泛型类与泛型接口代表

```java
java.lang.Comparable<T>：
    int compareTo(T t)
java.util.Comparator<T>：
    int compare(T t1, T t2)
java.lang.Iterable<T>：
    Iterator<T> iterator();
java.util.Collection<E>：
    void add(E e)
    ....
java.util.Iterator<E>:
	boolean hasNext()
    E next()
java.util.function.Predicate<T>:
	boolean test(T t)
```

（3）注意

在类或接口上面声明的泛型是不能用于静态成员上的。



### 3、通配符

（1）什么情况下使用通配符

当我们使用泛型类或泛型接口声明变量时，仍然无法确定<T>、<E>等的具体类型。可以考虑使用通配符。

```java
Collection<?> coll = new ArrayList<>();

public static void iter(Collection<?> coll){//形参也是变量
    for(Object obj : coll){
        System.out.println(obj);
    }
}
```

（2）通配符有三种形式：

- <?>：?代表任意类型
- <? extends 上限>：?代表 <= 上限的类型
- <? super 下限>：?代表>=下限的类型

（3）注意的问题

- <?>：?代表任意类型
  - 如果某个泛型类、接口<T>在使用时，泛型指定为<?>，那么他里面所有使用T类型声明形参的方法都不能正常使用了。
- <? extends 上限>：?代表 <= 上限的类型
  - 如果某个泛型类、接口<T>在使用时，泛型指定为<?  extends 上限>，那么他里面所有使用T类型声明形参的方法都不能正常使用了。
- <? super 下限>：?代表>=下限的类型
  - 如果某个泛型类、接口<T>在使用时，泛型指定为<?  super 下限>，那么他里面所有使用T类型声明形参的方法可以使用，只要不超过下限的类型都可以。

### 4、概念

（1）泛型变量

<泛型变量>：<T>、<E>，它通常都是单个的大写字母。

如果一个类或方法有多个的未知的类型，那么可以声明多个的泛型变量：<K，V>，<T,U,R>

泛型变量可以指定上限：<T extends  上限>，这里的上限可以是多个。多个上限的话，类只能有一个，而且一定在最左边。

```java
<T extends Number>
<T extends Comparable>
<T extends Number & Comparable & Cloneable>
```

（2）泛型实参

例如：<String>、<Integer>

泛型实参类型不能是基本数据类型和void，即不能出现<int>、<double>、<void>

（3）参数化的类型

例如：Collection<String>

（4）泛型数组

例如：T[] arr;

```java
T[] arr = new T[4]; //编译报错，因为T类型未知，这个编译器就无法确定调用哪个数组的构造器
```

（5）泛型擦除

当我们使用泛型类或泛型接口时，<T>没有指定类型，这个时候会发生泛型擦除，编译会有警告。

```java
Collection coll = new ArrayList();
//泛型擦除，编译会有警告，使用时，也会不方便。
```

泛型擦除后，<T>按照它的第一个上限处理，没有声明指定上限的，按照Object处理。

## day21早上复习

### 1、List接口的方法

（1）添加

- void add(元素)：添加一个元素

- void addAll(另一个Collection集合)：一次添加多个元素，把另一个Collection集合的元素都添加到当前集合中。

* void add(int index, E ele)
* boolean addAll(int index, Collection<? extends E> eles)

（2）删除

- remove(元素)：直接删除某个元素。目标对象与集合中的某个元素equals返回true时，就是被删除目标。

- removeAll（另一个Collection集合）：从当前集合中删除多个元素，即当前集合和另一个集合的“相同”元素就会被删除。

- retainAll(另一个Collection集合)：从当前集合中删除多个元素，即当前集合和另一个集合的“不相同”元素就会被删除。

- removeIf(Predicate p)：根据条件删除元素。如果集合中的元素满足Predicate 接口的test方法指定的判断条件时，就会被删除。

- clear()：清空集合中的所有元素。
- E remove(int index)：删除index位置的元素

（3）查找

- boolean contains（元素）：判断是否包含某个元素。

- boolean containsAll（另一个Collection集合）:判断另一个集合是否是当前集合的“子集”，即另一个集合的所有元素在当前集合中都能被找到。

- int size()：返回所有元素的个数

- Object[] toArray()：把所有元素放到一个Object[]中返回。

* E get(int index)：获取index位置的元素
* List subList(int fromIndex, int toIndex)：返回[fromIndex, toIndex)范围的元素
* int indexOf(Object obj)：查询某个元素的位置，如果有重复，返回第一个，不存在返回-1
* int lastIndexOf(Object obj)：查询某个元素的位置，如果有重复，返回最后一个，不存在返回-1

（4）修改

- E set(int index, E ele)：替换[index]位置的元素

（5）遍历

- foreach遍历
- Iterator<E> iterator()：返回一个迭代器对象，对集合的元素进行遍历
- ListIterator<E> listIterator()：返回一个列表迭代器对象，对集合元素进行遍历
- ListIterator<E> listIterator(int index)：从index位置开始从前往后或从后往前遍历。
  - ListIterator迭代器可以支持任意位置开始的从前往后或从后往前遍历。

### 2、List系列的集合实现类

- Vector：旧版的动态数组（线程安全的，默认扩容为原来2倍，默认初始化长度为10）
- ArrayList：相对新版的动态数组（线程不安全的，默认扩容为原来1.5倍，默认初始化长度为0）
- LinkedList：双向链表（它同时实现了List接口，还是实现Queue接口，Deque接口，又提供了peek,pop,push等方法使得LinkedList可以作为栈结构），相当于LinkedList它是多种数据结构的实现（队列、双端队列、栈、普通的双向链表等）
- Stack：栈，它是Vector的子类，也是通过peek,pop,push等方法体现为栈结构。
- ....

### 3、栈、队列的特点

栈：先进后出或后进先出

队列：先进先出

双端队列：两头都可以进，都可以出。

双端队列面试题：下面有这样一组数据，1,2,3,4,5，它可能的进去的顺序和出来的顺序有哪些或者哪些是不能的。

A，进：1,2,3,4,5，出：1,2,3,4,5

B：进：1,2,3,4,5，出：5,4,3,2,1

C：进：1,2,3,4,5，出：2,1,3,4,5

....

### 4、Set接口的实现类

- HashSet：不可重复，无序
  - 依据的hashCode方法和equals方法判断是否重复
  - 如果hashCode不同，那么就不用比较equals
  - 如果hashCode相同，接着比较equals
- TreeSet：不可重复，有大小顺序
  - 依据compareTo方法或compare方法
  - 如果两个对象调用compareTo方法或compare方法返回0，就认为相同
- LinkedHashSet：不可重复，可以保证遍历顺序和添加的顺序一致
  - 和HashSet一样判断是否重复

### 5、Set和Map的关系

Set的底层就是Map

### 6、Map接口的方法

（1）添加

* V put(K key,V value)：添加一对键值对
* void putAll(Map<? extends K,? extends V> m)：添加多对键值对

（2）删除

* void clear()：清空
* V remove(Object key)：根据key删除一对键值对

（3）修改：再次put，就修改value，不能修改key

（4）查询：

* V get(Object key)：根据key查询value（使用最多）
* boolean containsKey(Object key)：判断某个key是否存在
* boolean containsValue(Object value)：某个value是否存在
* boolean isEmpty()：是否为空

（5）遍历

* Set<K> keySet()：把所有的key提取出来遍历
* Collection<V> values()：把所有value提取出来遍历
* Set<==Map.Entry<K,V>==> entrySet()：把所有的键值对提取处理遍历

```java
Map.Entry类型
    Entry接口是Map接口的内部接口
```

### 7、Map接口的实现类

- Hashtable<K,V>：旧版哈希表（线程安全的，不允许key和value为null，底层是数组+链表）
- HashMap<K,V>：新版哈希表（线程不安全的，允许key和value为null，底层是数组+链表（JDK1.7）数组+链表/红黑树（JDK1.8））
- TreeMap<K,V>：红黑树，可以以key的大小进行排序
- LinkedHashMap<K,V>：是HashMap的子类，遍历时可以体现(key,value)的添加顺序
- Properties：它的key和value都是String，它的(key,value)添加一般用setProperty(key,value)，获取时，getProperty(key)

### 8、集合关系图

![](每日早上复习.assets/20200423210229.png)

## day22早上复习

### 1、Collections工具类

参考操作数组的工具类：Arrays。

Collections 是一个操作 Set、List 和 Map 等集合的工具类。Collections 中提供了一系列静态的方法对集合元素进行排序、查询和修改等操作，还提供了对集合对象设置不可变、对集合对象实现同步控制等方法：

* public static <T> boolean addAll(Collection<? super T> c,T... elements)将所有指定元素添加到指定 collection 中。
* public static <T> int binarySearch(List<? extends Comparable<? super T>> list,T key)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且必须是可比较大小的，即支持自然排序的。而且集合也事先必须是有序的，否则结果不确定。
* public static <T> int binarySearch(List<? extends T> list,T key,Comparator<? super T> c)在List集合中查找某个元素的下标，但是List的元素必须是T或T的子类对象，而且集合也事先必须是按照c比较器规则进行排序过的，否则结果不确定。
* public static <T extends Object & Comparable<? super T>> T max(Collection<? extends T> coll)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，而且支持自然排序
* public static <T> T max(Collection<? extends T> coll,Comparator<? super T> comp)在coll集合中找出最大的元素，集合中的对象必须是T或T的子类对象，按照比较器comp找出最大者
* public static void reverse(List<?> list)反转指定列表List中元素的顺序。
* public static void shuffle(List<?> list) List 集合元素进行随机排序，类似洗牌
* public static <T extends Comparable<? super T>> void sort(List<T> list)根据元素的自然顺序对指定 List 集合元素按升序排序
* public static <T> void sort(List<T> list,Comparator<? super T> c)根据指定的 Comparator 产生的顺序对 List 集合元素进行排序
* public static void swap(List<?> list,int i,int j)将指定 list 集合中的 i 处元素和 j 处元素进行交换
* public static int frequency(Collection<?> c,Object o)返回指定集合中指定元素的出现次数
* public static <T> void copy(List<? super T> dest,List<? extends T> src)将src中的内容复制到dest中
* public static <T> boolean replaceAll(List<T> list，T oldVal，T newVal)：使用新值替换 List 对象的所有旧值
* Collections 类中提供了多个 synchronizedXxx() 方法，该方法可使将指定集合包装成线程同步的集合，从而可以解决多线程并发访问集合时的线程安全问题
* Collections类中提供了多个unmodifiableXxx()方法，该方法返回指定 Xxx的不可修改的视图。

### 2、二叉树

二叉树（Binary tree）是树形结构的一个重要类型。二叉树特点是每个结点最多只能有两棵子树，且有左右之分。

```java
public class BinaryTree<E>{
    private TreeNode root; //二叉树的根结点
    private int total;//结点总个数
    
    private class TreeNode{
        //至少有以下几个部分
        TreeNode parent;
        TreeNode left;
        E data;
        TreeNode right;
        
        public TreeNode(TreeNode parent, TreeNode left, E data, TreeNode right) {
            this.parent = parent;
            this.left = left;
            this.data = data;
            this.right = right;
        }
	}
}
```

#### 二叉树的遍历

* 前序遍历：中左右（根左右）
* 中序遍历：左中右（左根右）
* 后序遍历：左右中（左右根）

![1574575739236](每日早上复习.assets/1574575739236.png)

前序遍历：ABDHIECFG

中序遍历：HDIBEAFCG

后序遍历：HIDEBFGCA

#### 经典二叉树

1、满二叉树： 除最后一层无任何子节点外，每一层上的所有结点都有两个子结点的二叉树。 第n层的结点数是2的n-1次方，总的结点个数是2的n次方-1

![1574575163883](每日早上复习.assets/1574575163883.png)



2、完全二叉树： 叶结点只能出现在最底层的两层，且最底层叶结点均处于次底层叶结点的左侧。

![1574575180247](每日早上复习.assets/1574575180247.png)



3、平衡二叉树：平衡二叉树（Self-balancing binary search tree）又被称为AVL树（有别于AVL算法），且具有以下性质：它是一 棵空树或它的左右两个子树的高度差的绝对值不超过1，并且左右两个子树都是一棵平衡二叉树， 但不要求非叶节点都有两个子结点 。平衡二叉树的常用实现方法有红黑树、AVL、替罪羊树、Treap、伸展树等。例如红黑树的要求：

- 节点是红色或者黑色
- 根节点是黑色

- 每个叶子的节点都是黑色的空节点（NULL）

- 每个红色节点的两个子节点都是黑色的。

- 从任意节点到其每个叶子的所有路径都包含相同的黑色节点数量。


当我们插入或删除节点时，可能会破坏已有的红黑树，使得它不满足以上5个要求，那么此时就需要进行处理：

1、recolor ：将某个节点变红或变黑

2、rotation ：将红黑树某些结点分支进行旋转（左旋或右旋）

使得它继续满足以上以上的5个要求。

![](每日早上复习.assets/红黑树.jpeg)



例如：插入了结点21之后，红黑树处理成：

![](每日早上复习.assets/红黑树2.jpeg)



### 3、哈希表

请看《关于HashMap的面试问题.md》

## day23早上复习

### 1、java.io.File类

1、File类是用来在程序中表示一个文件或目录，这个文件或目录可能是真实存在的，也可能暂时不存在的。
如果它真实存在，即根据创建File类的“路径”能够找到这个文件或目录的，那么系统会将文件或目录的相关信息自动赋值给File类对象。
否则除了路径名（path,name等）之外，所有其他属性都是默认值。

2、File类API
（1）String getName()：获取文件或目录名
（2）long length()：只能得到文件的大小，返回字节数，如果是目录（文件夹）需要把它下面的所有文件大小都累加起来
（3）long lastModified()：获取文件或目录的最后时间，返回毫秒值
（4）boolean isFile()：如果文件不存在，就算是File类的对象是表示一个文件，也仍然返回false
                        只有真实存在的，确实是一个文件的，才会返回true
         File f3 = new File("D:\\Download\\img\\美女\\chailinyan.jpg");//这个chailinyan.jpg没有
（5）boolean isDirectory()：如果目录不存在，就算是File类的对象是表示一个目录，也仍然返回false
                        只有真实存在的，确实是一个目录的，才会返回true
（6）boolean exists()：是否存在
（7）boolean canRead()：是否可读
（8）boolean canWrite()：是否可写
（9）boolean isHidden()：是否隐藏
（10）路径
A：标准的，在所有的操作平台都支持的路径分隔符“/"
B：在创建File时，构造器的（）中描述的路径名称为构造路径，它可以是绝对路径也可以是相对路径，
还可以包含“../”非规范路径。
C：String getAbsolutePath()：获取绝对路径
D：String getPath()：获取构造路径
E：String String getCanonicalPath()throws IOException：获取规范路径，会把构造路径中的../进行解析
（11）boolean createNewFile()：只能创建一个文件
（12）boolean mkdir()：只能创建一个文件夹，如果父目录不存在，创建不成功，但不报异常
     boolean mkdirs()：创建文件夹，如果父目录不存在，会一并创建
（13） boolean delete() :只能删除文件或者说空目录
（14）boolean renameTo(File dest) ：当前的File对象调用了renameTo方法之后，就会把当前File对象的相关属性赋值给dest的File对象。
（15）String[] list()：获取某个目录的下一级的文件或目录的名称
（16）File[] listFiles()获取某个目录的下一级的文件或目录的File对象
（17）File[] listFiles(FileFilter f)获取某个目录的下一级的文件或目录的File对象，可以过滤File对象，看是否满足xx条件

### 2、IO流

#### （1）四个抽象父类

InputStream：字节输入流
OutputStream：字节输出流
Reader：字符输入流
Writer：字符输出流

#### （2）四个抽象父类的方法

**InputStream：**

int read()：读取一个字节，返回读取的字节值，如果到达流末尾，再读就返回-1。
int read(byte[] data)：一次最多读取data.length个字节，返回实际本次读取的字节数量。如果到达流末尾，再读就返回-1。
                    读取的数据就临时的存储到data中，从data[0]开始存储，
                    如果data数组循环使用的话，每一次读取都会从data[0]开始覆盖，
                    如果本次读取的字节数量没有凑够data.length个，本次一共读取count个字节，
                    那么要注意剩下的data[count, data.length-1]元素可能默认值0，也可能是上次读取的内容。
int read(byte[] data, int off, int len)：一次最多读取len个字节，返回实际本次读取的字节数量。如果到达流末尾，再读就返回-1。
                    读取的数据就临时的存储到data中，从data[off]开始存储，
void close()：关闭IO流

**Reader：**

int read()：读取一个字符，返回读取的字符的Unicode值，如果到达流末尾，再读就返回-1。
int read(char[] data)：一次最多读取data.length个字符，返回实际本次读取的字符数量。如果到达流末尾，再读就返回-1。
                    读取的数据就临时的存储到data中，从data[0]开始存储，
                    如果data数组循环使用的话，每一次读取都会从data[0]开始覆盖，
                    如果本次读取的字符数量没有凑够data.length个，本次一共读取count个字节，
                    那么要注意剩下的data[count, data.length-1]元素可能默认值0，也可能是上次读取的内容。
int read(char[] data, int off, int len)：一次最多读取len个字符，返回实际本次读取的字符数量。如果到达流末尾，再读就返回-1。
                    读取的数据就临时的存储到data中，从data[off]开始存储，
void close()：关闭IO流

**OutputStream：**

void write(int d)：输出一个字节
void write(byte[] data)：输出整个字节数组
void write(byte[] data,int off, int len)：输出字节数组data的len个字节，从data[off]开始
void close()

**Writer：**

void write(int d)：输出一个字符
void write(char[] data)：输出整个字符数组
void write(char[] data,int off, int len)：输出字节数组data的len个字符，从data[off]开始
void write(String str)：输出整个字符串
void write(String str,int off, int len)：输出字符串一部分，len个字符，从str[off]开始
void close()：关闭IO流

void flush()：刷新流中的数据



### 3、文件IO流

FileInputStream：文件字节输入流
FileOutputStream：文件字节输出流
FileReader：文件字符输入流，而且要求文件的编码和程序编码一致。
FileWriter：文件字符输出流，而且要求文件的编码和程序编码一致。

FileInputStream和FileOutputStream适用于操作任意类型的文件。
FileReader和FileWriter只适用于操作纯文本文件，文件中不能有图片，视频等各种多媒体素材，即文件中只有各种字符。

FileInputStream和FileReader只能用来读取文件的内容。
FileOutputStream和FileWriter只能用来输出数据到文件。

```java
什么是纯文本文件？
文件中只能出现字符。
通常纯文本文件的类型：
    .txt，.java，.html，.js,.css，.sql......
不是纯文本的文件：
    word，excel，ppt
```



### 4、缓冲IO流

BufferedInputStream：给InputStream系列的IO加缓冲功能
BufferedOutputStream：给OutputStream系列的IO加缓冲功能
BufferedReader：给Reader系列的IO加缓冲功能
				或者是需要按行读取  String readLine()方法
BufferedWriter：给Write系列的IO加缓冲功能

			 或者是需要按行输出  void newLine()

### 5、转换流

InputStreamReader：
	（1）需要把字节输入流的类型转为字符输入流的类型。包装的是字节流，本身是字符流。
	（2）当读纯文本文件的数据时，遇到了文件的编码和程序的编码不一致，
		需要它配合FileInputStream完成。
OutputStreamWriter：
	（1）需要把字节输出流的类型转为字符输出流的类型。包装的是字节流，本身是字符流。
	（2）当输出纯文本数据时，遇到了文件的编码和程序的编码不一致，
		需要它配合FileOutputStream完成。

### 6、读写Java各种数据类型的IO流

DataOutputStream：要输出的数据除了字符串之外还有其他Java的基本数据类型的数据或者字节数组		
DataInputStream：用于读取用DataOutputStream输出的数据

ObjectOutputStream：支持输出Java的各种数据，包括基本数据类型和对象。要输出Java对象时，配合Serializable接口。
ObjectInputStream：支持读取Java的各种数据类型的数据，包括基本数据和对象。要读取Java对象时，读取ObjectOutputStream输出的数据时。

序列化：

- 把Java的对象转为字节数据进行输出。
- 需要Java对象类型实现java.io.Serializable接口。如果Java对象中某个属性也是引用数据类型，那么这个属性想要参与序列化也要求该类型实现Serializable接口。
- 序列化过程中某些 成员变量的值是不能序列化：static和transient修饰的成员变量值是不序列化
- 为了在类做了修改之后，原来的数据仍然可以被反序列化，通常要求在实现Serializable接口时，加一个序列化版本ID。

```java
private static final long serialVersionUID = -6849794470754667710L;
```

反序列化：

- 把字节数据转换为一个Java对象。
- 反序列化时，要求Java对象对应的类必须存在，否则会报ClassNotFoundException。

### 7、IO流的选择

```java
/*
IO流的分类：
（1）根据数据的流向分：
输入流：InputStream、Reader系列，
        只能从输入流中读取数据，调用read系列的方法
        read() readInt()  readUTF()  readObject()....
输出流：OutputStream、Writer系列、包括PrintStream、PrintWriter
        只能往输出流中写数据，调用write，print系列的方法
        write(...)  writeInt(...) writeUTF(...) print(..) println(...)

（2）根据操作数据的基本单位分：
字节流：以字节为单位，所有的操作都要转为字节、字节数组
    InputStream和OutputStream系列
    FileOutputStream、BufferedOutputStream、DataOutputStream、ObjectOutputStream
    FileInputStream、BufferedInputStream、DataInputStream、ObjectInputStream

PrintStream：从流的类型来说是字节流，但是它里面的print，println方法支持各种数据类型。
字符流：以字符为单位，只支持纯文本数据的处理
    Reader和Writer
    FileReader、BufferedReader、InputStreamReader、Scanner
    FileWriter、BufferedWriter、OutputStreamWriter、PrintWriter

（3）根据流的角色分：
节点流：FileInputStream、FileOutputStream、FileReader、FileWriter
处理流：BufferedInputStream、BufferedOutputStream、BufferedReader、BufferedWriter   装饰流，需要包装别人才能
        DataInputStream、DataOutputStream
        ObjectInputStream、ObjectOutputStream
        PrintStream、PrintWriter

IO流的整个体系设计是采用了“装饰者设计模式”。

什么是装饰者设计模式？
（1）被装饰者
A：节点流只能作为被装饰者
节点流（例如节点流：FileInputStream、FileOutputStream、FileReader、FileWriter），
节点流（例如节点流：ByteArrayInputStream、ByteArrayOutputStream），只能作为被装饰者
节点流（例如节点流：CharArrayReader、CharArrayWriter），只能作为被装饰者
它们的构造器指定的是数据的来源或者数据的目的地，例如：文件、数组。

B：装饰者同时也可以作为被装饰者


（2）装饰者
处理流，都是装饰者，必须依赖于其他的IO流
例如：BufferedInputStream bis = new BufferedInputStream(其他InputStream流的对象);

装饰？
比喻：穿衣服加装饰
加个丝巾、领带、胸针等
装饰品属于在原来被装饰的衣物或其他装饰品基础上再加新的功能（更好看、更暖和）。


装饰者设计模式是替换继承的方式。
如果不用装饰者模式，那么子类的数量是爆炸式的增长。

继承的方式：
文件流是最基础的，
需要一个新的类型：在文件流的基础上仅支持缓冲  FileBufferedXxx
需要一个新的类型：在文件流的基础上既支持缓冲又支持转码  FileBufferedTransferXxx
需要一个新的类型：在文件流的基础上只支持转码  FileTransferXxx
。。。。


 */


```

### 8、try...catch的新语法（JDK1.7之后）

```java
try(需要自动关闭的资源类对象的声明和创建){
    可能发生异常的业务逻辑代码
}catch(异常类型 e){
    异常处理代码
}【finally{
    其他必须执行的代码。
}】    
```

注意：

（1）写在 try()中的资源类对象的类型必须实现AutoCloseable接口

（2）写在 try()中的资源类对象自动加final

（3）资源类类的类型有哪些，通常有IO流类，后面有数据库连接类，网络连接类。这些通常操作完都需要close,，它们实现AutoCloseable接口之后，就可以自动关闭，不用手动写close方法了。当执行完try...catch部分的代码之后，就会自动关闭。

## day24早上复习

### 1、网络编程

本章（网络编程）整个的API不是重点，
但是：
（1）可以通过刚才类似的几个案例（综合），可以把最近学习的一些其他章节API使用练习一下
（2）理解网络程序交户模式
C/S结构：明显的客户端和服务端，必须同时开发和维护两套应用程序。
B/S结构：客户端显示格式和工具是固定的，由浏览器代替客户端。
       JavaEE项目中大家主要编写的是服务器端代码。
       但是也要编写一些客户端的代码，这个部分改为  如果把内容在浏览器中进行展示。
       浏览器中展示内容：依赖于  html标签（骨架） 、CSS样式（美化）、Javascript（客户端的交互）
       经过一些js的交互，可以减少一些客户端与服务器端的交互，例如：对用户输入数据的格式校验
       当然，也可以通过js发起和服务器的交互。
       或者通过页面请求，或表单提交等方式与服务器端进行交互。

 web阶段：
       （1）html标签（骨架） 、CSS样式（美化）、Javascript（客户端的交互），有了它们才能更好的
       在浏览器中展示内容。
       （2）服务器端如何接收用户的请求，处理请求、响应请求
       （3）服务器端的程序要在web容器（web服务器）中运行，例如其中一个web服务器就是tomcat。

JavaSE和web阶段之前会插入一个mysql+jdbc。
有了它，才能真正的编写一个JavaEE项目。JavaEE方向后面也会学习其他的数据库（redis等）

有了它，大数据方向才能实现从mysql数据库提前数据到大数据的相关的框架、工具中进行处理和分析，等分析完数据之后，也可能会需要把分析的结果存回mysql数据库。当然大数据方向后面还会学习很多其他的sql等。

三层结构：视图层、业务逻辑层、数据访问层
        视图层和业务逻辑层之间需要网络编程
        数据访问层与数据库DB之间需要网络编程。





### 2、反射


1、为什么要用反射？
需要在运行时才能确定要使用哪个类，通过某种方式（例如读取配置文件等）获取了类的全名称，
然后在运行时动态的加载这个类，获取这个类的Class对象，然后创建这个类自己的实例对象，再去操作它的属性和方法等。

后期大家学习的web项目、框架等都是这么干的。包括我们接下来学习的JDBC很多公共的基础API也是使用反射。

2、类的加载

- 类的加载的过程（不用程序员做）（了解）
  （1）加载：load，把xx.class读取到内存
  （2）连接：link，和现有的JVM内存中的其他类或常量等建立联系
  A：检查校验字节码数据是否合法
  B：准备内存：静态变量，静态常量等的内存，而此时静态常量直接初始化，静态变量先赋默认值。准备Class对象的内存。
  C：把字节码中的符号引用替换为直接的内存地址引用（和现有的JVM内存中的其他类或常量等建立联系）4
  （3）初始化：调用<clinit>方法为静态变量初始化
  有时候初始化会延迟，有时候初始化直接就在类加载的时候一并完成了。

- 延迟
  （1）在使用这个类的时候，只是使用这个类的静态的常量（static final），此时还不需要初始化
  （2）在使用子类时，只是通过子类调用父类的静态的成员，此时子类也不着急初始化，只需要完成父类的初始化就可以了。子类要加载但是不着急初始化。
  （3）在使用某个类声明了一个数组类型，并且创建数组对象，还未创建元素对象，此时元素类型不着急初始化。
  但是元素类型是要加载的。
  此时会动态编译生成一种新的类型，数组类型。
  例如：Student类
  声明一个Student[]数组，此时会动态编译生成一个新的类型“Student[]”

- 不延迟
  （1）使用这个类直接new对象，必须先初始化类，才能new对象
  之前说只有类初始化完成，才能进行实例初始化（new对象就是实例初始化）
  （2）如果要初始化子类，那么必须先初始化父类
  （3）如果要使用某个类的静态变量（非常量），静态的方法，也要先初始化这个类
  （4）如果某个类包含main方法，在main执行之前，这个类也要先初始化
  （5）通过反射的API使用某个类，也要先将这个类初始化的。

3、类加载器
作用：
（1）最主要的作用：加载类，读取字节码数据
字节码数据绝大多数都是在xx.class文件中，
但是也有一些字节码数据是在数据库等其他系统中，
或者在某个字节数组（动态编译生成的）中。

（2）顺便的作用：顺便帮忙加载类路径下的资源文件
项目的运行其实是有一个 classpath

分类：

（1）根加载：负责加载核心类库中的rt.jar等类，它本身不是Java语言实现的，所以得不到它的对象，得到的是一个null值。

（2）扩展类型加载：负责加载 jre/lib/ext文件夹下的扩展库中的jar

（3）应用程序类加载器：负责加载当前项目中自己写的类的代码

（4）自定义类加载器：一般用于字节码加密和解密，或者说像tomcat一样需要加载特定目录下类，以及要区分不同web项目（JavaEE项目）的不同lib库。

类加载器的工作模式：双亲委托模式。

4、API

（1）获取Class对象的四种方式

```java
第一种：类型名.class
第二种：对象.getClass()
第三种：Class.forName("类型的全名称")
第四种：类加载器对象.loadClass("类型的全名称")
```

（2）获取类加载器对象的方法

```java
第一种方式：
    Class对象.getClassLoader()

第二种方式：获取当前系统默认的类加载器
    ClassLoader.getSystemClassLoader()
```

5、反射的应用相关的API

（1）获取类的详细信息

获取类的包名、类名、修饰符、父类、父接口、成员变量、构造器、成员方法...。

可能会涉及到的类有：Class、Package、Modifier、Constructor、Field、Method

步骤：

第一步：先获取Class对象

第二步：通过Class对象.getXxx获取详细信息

（2）在运行时动态的创建某个类的对象

方式一：如果这个类有公共的无参构造

- 第一步：先获取Class对象
- 第二步：通过Class对象.newInstance()创建实例对象

方式二：可以根据这个类的任意一个构造器创建对象

- 第一步：先获取Class对象
- 第二步：先获取某个具体的构造器Constructor对象
- 第三步：通过Constructor对象.newInstance(【实参】)创建实例对象