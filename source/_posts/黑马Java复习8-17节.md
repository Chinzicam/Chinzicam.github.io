---
title:  JavaSE每日复习8-17节（黑马资源
author: 橙子草草
date: 2022-10-06 13:40:40
tags:
- java
- 复习
categories: 
- java笔记
cover: true
sidebar: [blogger, category, toc] ## 放置任何你想要显示的侧边栏部件
---

## day8早上复习

### 1、实例变量的内存分析

- 所有实例变量的值是存储在堆中。
- 每一个对象的实例变量是独立的。



### 2、类的成员之二：成员方法

#### 2.1 成员方法的原则

```
方法必须先声明后使用
方法不调用不执行，但是调用一次就会执行一次。
```

#### 2.2 成员方法的语法格式

```java
【修饰符】 返回值类型 方法名(【形参列表】){
    方法体语句
}
```

【修饰符】：有很多，后面会一一学习，public, protected, private ,static, final, abstract等

返回值类型：

- void：没有结果返回，方法体中不能加"return ==值==; "，但是可以有“return ;"，它表示的意思是提前结束方法的执行。
- 非void，可以是基本数据类型，可以是数组类型，可以是其他的引用数据类型：这个时候就表示有结果返回，方法体中必须保证==有“return 值;"语句==，而且要求return后面的值的类型与方法名前面的返回值类型一致或兼容。

方法名：见名知意，从第二个单词开始首字母大写。

【形参列表】：当方法功能的实现需要外界传入数据时，就要有参数，即代表未知数据

- ()：无参，调用时，不用给方法传任何数据，但是()不能丢
- (数据类型 参数名 【, 数据类型 参数名, ...】)：有参，调用时，必须传入对应类型和个数的实参。

方法体：完成方法功能的语句



#### 2.3 方法的执行过程

入栈：每次调用都会在栈中开辟一块独立的内存空间，用于存储方法的局部变量等信息，这个过程就叫做入栈。

出栈：方法运行结果，自动释放对应的栈空间，这个过程称为出栈。

如果有多个方法被调用，先调用的先入栈，先完成的先出栈。遵循先进后出的顺序。



### 3、可变参数

1、可变参数：  (数据类型... 参数名)

2、可变参数的要求：

可变参数一个方法只能有一个，而且必须是最后一个

3、可变参数的使用

（1）声明它的方法中，当成数组使用

（2）调用它的方法时，

A：传入对应类型的数组

B：传入0~n个对应类型的元素

### 4、局部变量和实例变量的区别

|          | 声明位置           | 在内存中存储的位置 | 生命周期               | 作用域                                      | 修饰符      |
| -------- | ------------------ | ------------------ | ---------------------- | ------------------------------------------- | ----------- |
| 局部变量 | 方法的()或{方法体} | 栈                 | 每次方法调用都是独立   | 有作用                                      | 只能有final |
| 实例变量 | 类中方法的外面     | 堆                 | 和对象的生命周期是一样 | 本类中直接使用，其他类中通过“对象."进行使用 | 有很多      |



## day9早上复习

### 1、包

如何声明包？

```java
package 包名;
```

包名所有单词都小写，每一个单词/每一个层级之间使用“."分割。习惯上每个公司会用自己公司的域名倒置+ 具体功能模块名。

如何跨包使用类？

类要被跨包使用，这个类必须是public修饰。

类中的成员要跨包使用，也是需要public修饰的（当然后面子类另说）。

使用跨包的类的方式有两种：

```java
(1)全名称   包.类名
(2)import 包.类名;  在package语句下面(当前.java文件的所有类的上面)加import语句，在代码中使用简单的类名即可。
```

例如：

```java
package com.atguigu.one;
public class One{
    
}
```

```java
package com.atguigu.two;

import com.atguigu.one.One;

public class Two{
    One one;
}
```

```java
package com.atguigu.two;

public class Two{
    com.atguigu.one.One one;
}
```

包的作用：

（1）避免的类的重名

（2）组织管理不同的类

后面会学习Java核心类库中：

java.lang：它是核心类中最最基础的类，例如：String，Math，System等。  默认情况下，java.lang包的所有类都不需要加包名，就可以直接使用简单的类名称。

java.util：它是各种工具类，例如：Arrays数组工具类、Scanner用于键盘输入等

java.io：它是用于输入、输出数据的各种IO流，文件操作等。例如：File类，FileInputStream类等。

。。。。

（3）权限控制

如果类、成员，权限修饰符（public等）省略的，默认只能在本包使用，跨包不能使用。



### 2、命令行参数（了解）

它是main方法传的实参。

```java
java命令  主类名  参数值1 参数值2  参数值3 ...
```

在IDEA中：

![image-20220118084247613](每日早上复习.assets/image-20220118084247613.png)

![image-20220118084330886](每日早上复习.assets/image-20220118084330886.png)

### 3、方法的重载

方法的重载的定义：在同一个类中，==方法名相同，形参列表不同（个数不同、类型不同）==的两个或多个方法，称为方法的重载。

方法的重载和返回值类型无关，即不看返回值类型。

返回值类型要看你当前方法计算的结果类型是什么。

调用重载的方法时，需要遵循如下原则：

1、先找最匹配的（实参的类型和个数与形参的类型和个数完全一致），如果1找到了，就不看2了。

2、再找唯一可以兼容的（个数或类型可以兼容）

一旦找到多个可以兼容或者0个可以兼容，那么都会编译报错。

### 4、方法递归调用

当方法出现自己调用自己的情况时，就是递归调用。

要避免出现“无限循环递归”，因为这样的话，会出现“栈内存溢出StackOverflowError”。

要使用递归，一定是有条件的，满足xx条件的情况下才递归。

另外，建议凡是能够使用循环解决的，尽量使用循环解决，除非递归的深度不深。



### 5、对象数组

元素类型是引用数据类型的数组。对象数组可以是一维数组，也可以是二维数组。

元素存储的是对象的首地址。在使用对象数组时，要注意两点：

（1）元素的默认值是null，所以要记得给元素new对象。否则会出现NullPointerException。

（2）元素是引用数据类型，==元素就是对象==，它可以调用元素类型所声明的属性和方法

```java
public class Student{
	String name;
    int score;
    
    String getInfo(){
        return "姓名：" + name + "，成绩：" +score;
    }
}
```

```java
public class TestStudent{
    public static void main(String[] args){
        Student[] arr = new Student[3];//此处创建的不是学生对象，是数组对象
        
        arr[0] = new Student();//此处创建的才是学生对象
        arr[0].name = "张三";
        arr[0].score=  89;
        System.out.println(arr[0].getInfo());
    }
}
```



### 6、方法的参数传递机制

（1）实参给形参传值

（2）分为两种情况：

- 形参是基本数据类型：
  - 实参给形参的是数据值的副本，形参无论怎么修改，都和实参无关。除非把修改的值返回，并重新接收。

- 形参是引用数据类型
  - 实参给形参的是地址值的副本，如果在方法体中，形参没有指向“新对象”，那么形参对象做的任何修改都和实参有关。
  - 换句话说，从形参指向“新对象”之后，形参对象所有的修改都和实参对象无关了，除非把对象返回，并重新接收。



## day10早上复习

### 1、问题

#### 问题1：set方法和get方法的作用到底有什么区别？

或者换句话说，什么时候用set，什么时候用get？

```java
set方法：用于修改值，你必须给他传值
get方法：用于查询值/获取值，不用给他传值
```

```java
举例：ATM存钱和查询余额
查询余额：调用get方法，直接返回卡的“余额”，不用给ATM机钱，不用提供钱的数量，不用提供参数
存钱：调用set方法，给ATM机提供“钱”（参数），内部会修改卡的“余额”。    
```

#### 问题2：如果子类出现了和父类方法名相同，形参列表不同的方法，算重载还是重写？

```java
package com.atguigu.review;

public class TestOverloadAndOverride {
    public static void main(String[] args) {
        Son s = new Son();
        s.method(1.2);
        s.method(1);
        /*
        发现Son类的对象，可以调用两个method方法，
        那么这两个method方法是什么关系？
        （1）是重写吗？显然不是
        （2）是重载吗？可以说是
            虽然public void method(int a)在父类中声明，
            但是因为子类会继承这个方法，可以看成子类也拥有这个方法。
         */
    }
}

class Father{
    public void method(int a){
        System.out.println("a = " + a);
    }
}
class Son extends Father{
    public void method(double a){
        System.out.println("a = " + a);
    }
}
```



### 2、封装

#### 2.1 封装的意义或者说好处

```java
目的：
    安全，隐藏内部的实现细节
    使用更简单，只暴露少了的公共的方法等，减少了外部需要了解的信息（回忆洗衣机，只暴露几个按钮和入水口、出水口、衣服的入口，内部的复杂结构隐藏，大家就不用去了解，也使用更简单）
```

#### 2.2 如何实现封装

依靠权限修饰符。

```java
				private  缺省	protected 	public
本类				yes		yes		yes			yes		
本包				no		yes		yes			yes
其他包的子类		  no	  no	 yes		 yes
其他包的非子类		 no		 no		no			yes

修饰类（这里指外部类）：只能public和缺省
修饰成员（目前学习的成员主要是实例变量，实例方法）：可以四种任选一种
```

#### 2.3 如果属性私有化了，怎么处理

如果属性私有化了，可以给他提供get或set方法？

是否一定要给私有化的属性提供get和set方法？不一定，看需要。

如果要提供的话，get/set方法的要求或模板：

```java
get方法：
    public 属性的数据类型 get属性名(){ //如果属性是boolean类型，会把get换成is
    	return 属性;
	}
set方法：
    public void set属性名(属性的数据类型 属性名){
    	//可以加其他的逻辑判断
    	this.属性名 = 属性名;
	}
```



### 3、继承

#### 3.1 继承的意义

```java
继承的好处：
    可以实现代码的复用和代码的扩展
    可以用来表示两个类（事物）之间is-a的关系
```

#### 3.2 继承的关键字

```java
extends
```

#### 3.3 继承的特点和要求

```java
（1）子类会继承父类所有的实例变量和实例方法。
只要权限修饰符允许，子类中可以直接访问父类中声明的所有实例变量和实例方法。
只要权限修饰符允许，在其他类中，通过子类对象可以调用父类中声明的所有实例变量和实例方法。
（2）Java只支持单继承
（3）Java支持多层继承
面试题会出现：多重继承（同时可以有多个直接父类，错误）和多层继承
（4）Java中同一个父类可以同时有多个子类
（5）其他的后面在补充
```

#### 3.4 方法的重写

```java
Overload：方法的重载
Override：方法的重写
区别：	方法名		形参列表	返回值类型		权限修饰符		其他
重载	必须相同	必须不同	无关/不看		不看			不看
重写	必须相同	必须相同	有要求			有要求			后面再说
			
重写时：			
返回值类型：基本数据类型和void必须相同，引用数据类型可以是<=
权限修饰符：总体来说是>=，
			在子类中不可见的方法是不能被重写（例如：private，跨包的话缺省的情况下）
```

## day11早上复习

### 1、多态

面试题：

（1）面向对象的基本特征有哪些？

```java
封装、继承、多态
```

（2）面向对象的特征有哪些？

```java
封装、继承、多态、抽象
```

#### 1.1 多态的意义

```java
使得代码的编写更灵活，功能更强大。
更专业的答案是：可以实现虚方法的动态绑定
```



#### 1.2 多态现象发生的前提

```java
（1）继承
（2）有多态引用
    父类类型 变量 = 子类的对象;
变形：
    A：父类的类型[] 数组名 = new 父类的类型[长度];
		数组名[下标] = 子类的对象;
	B：形参的类型是父类的类型，实参是子类的对象
    C：方法的返回值类型是父类的类型，返回的实际结果是子类的对象
    D：某个成员变量声明的是父类的类型，实际接收的是子类对象
 总结：父类类型的变量/元素中存储了子类的对象（子类对象的首地址）
（3）通过多态引用的父类类型的变量/元素“调用虚方法”
虚方法：可以被子类“重写”的方法
        
如果通过多态引用的父类类型的变量/元素调用的是非虚方法，或者是成员变量，那么不用考虑多态的问题，只看变量/元素的“编译时类型”。
```



#### 1.3 多态现象

```java
编译时看父类
运行时看子类
    如果子类重写的了“虚方法”，那么就一定执行的是重写后的代码。
    如果子类没有重写“虚方法”，那么还是执行父类中的方法体。
```



#### 1.4 变量/对象的类型

```java
运行时类型：就是new关键字后面出现的类型名，从new出来之后，就不会改变。
编译时类型：可以变化的
    （1）当把对象赋值给一个父类变量/元素时，就会像上转型为父类类型
    （2）当把对象“向下转型”为子类类型时，就会转为子类类型
    （3）当然也可以手动的“向上转型”为父类的类型，即(父类类型)子类对象，也会转为父类类型

如果调用的是虚方法，那么要关注的是对象的运行时类型。
如果调用的是非虚方法，或者成员变量，那么要关注的是对象的编译时类型。
```

```java
什么是编译时类型？
（1）对于变量来说，变量声明时，左边的类型就是它的编译时类型
（2）对于强制类型转换来说，()中写的类型是什么，它的编译时类型就是什么。如果有连续多次的强制类型转换，看最后一次。
```

## day12早上复习

### 1、实例初始化

#### 1.1 构造器（掌握）

1、作用

```java
(1)跟在new后面，用来创建"对象
    new Student();
	new Student("张三",23,89);
	
	new Scanner(System.in);
（2）在new的同时，把对象的实例变量进行初始化
    构造器的代码最终是合并到<init>这样的实例初始化方法中执行的
```

2、构造器的特点

```java
（1）构造器的名称必须和类名完全一致，如果不一致就报错了
（2）构造器没有返回值类型，不写void，以及其他数据类型
    一旦写了返回值类型，就成了普通方法，就不是构造器了。
（3）构造器的修饰符只能是权限修饰符，不能有其他修饰符（final，native，static等）
    权限修饰符：public、protected、缺省、private
（4）如果一个类没有编写任何构造器，那么编译器会自动添加一个默认的无参构造，这个默认的无参构造的权限修饰符和class类前面的权限修饰符保持一致。
    如果我们手动编写了任何一个构造器，那么编译器就不会再自动给你添加无参构造了。如果需要无参构造，就要自己编写。
（5）构造器可以重载多个。
（6）构造器是不会被继承到子类的，但是子类构造器又必须调用父类的构造器。
    默认情况下，调用父类的无参构造，相当于子类构造器的首行有super();，这句代码可以省略。
    如果父类没有无参构造，子类必须手动编写构造器，否则编译报错，而且在子类构造器的首行必须加super(实参列表);
	如果父类既有无参构造，又有有参构造，那么子类构造器的首行，可以根据需要自己选择super();或是super(实参列表);分别表示调用父类的无参构造，或有参构造。
```

3、构造器的语法结构

```java
【修饰符】 class 类名{
    【权限修饰符】 类名(){ //无参构造
        ....
    }
    【权限修饰符】 类名(形参列表){ //有参构造
        ....
    }
}
```

4、构造器使用IDEA生成的快捷键：Alt + Insert选择Constructor

#### 1.2 非静态代码块（了解）

1、作用

```java
辅助构造器完成对象的实例初始化，通常就是把每一个构造器的一些公共的可提前的代码抽取到非静态代码块中，可以减少代码的冗余。
```

2、执行特点

```java
随着构造器被调用，而执行的，而且一定是先于构造器的代码执行（当然构造器首行的super();或super(实参列表);更早）。
```

3、语法结构

```java
【修饰符】 class 类名{
    {
        非静态代码块;
    }
}
```

#### 1.3 实例初始化的过程（了解）

1、实例初始化的过程由以下几个部分的代码组成

```java
（1）构造器首行的super() 或 super(实参列表); ==> 代表父类的实例初始化方法<init>() 或 <init>(形参列表)
（2）成员变量声明后面的显式赋值
（3）非静态代码块
    其中（2）和（3）要看编写的顺序，谁先写的，谁就先执行。
（4）构造器中除了首行的 super() 或 super(实参列表);剩下的其他代码   
```

### 2、关键字

#### 2.1 this

1、this的意思

```java
当前对象
（1）在构造器或非静态代码块等和实例初始化有关的代码中，表示正在new的那个对象。
    
    警惕：在父类的构造器或非静态代码块中等，这个时候this，不见得就一定是父类的对象，而可能是子类的对象。
    因为在new子类对象时，会因为子类构造器中的super()或super(实参列表)调用到父类的构造器等。
 
（2）在实例方法中，表示调用这个方法的对象，即调用方法时，.前面的那个对象的“运行时类型的对象”
```

2、this的用法

```java
(1)this.成员变量
    在本类中使用本类声明的成员变量，如果没有重名问题，那么完全可以省略this.。
    在子类中使用父类声明的成员变量（权限修饰符允许该成员变量在子类可见），如果没有重名问题，也完全可以省略this.。
    当在构造器，或实例方法等当中，出现了“局部变量”和“成员变量”重名时，才需要在成员变量的前面加“this.”。
    this.成员变量，不见得就是本类声明的成员变量，也可以是父类声明的成员变量（权限修饰符允许该成员变量在子类可见）。

（2）this.成员方法
    在本类中使用本类声明的成员方法，可以通过this.成员方法进行访问，也完全可以省略this.。
    在子类中使用父类声明的成员方法（权限修饰符允许该成员变量在子类可见），如果该成员方法没有被“重写”，也可以通过this.成员方法进行访问，或者完成省略this.。
    
    this.成员方法，不见得就是本类声明的成员方法，也可以是父类声明的成员方法（权限修饰符允许该成员变量在子类可见）。
    this.成员方法（当然这个方法得是虚方法），如果此时this是代表子类的对象，那么有可能执行的是子类“重写”的方法。

（3）this() 或 this(实例列表)
    A：它只能出现在构造器的首行
    B：它只能找本类的构造器，不会找到别的类中去
```

#### 2.2 super

1、super的意思

```java
super：代表从父类中找xx
```

2、super的用法

```java
(1)super.成员变量
    在子类中使用父类声明的成员变量（权限修饰符允许该成员变量在子类可见），如果没有重名问题，也完全可以省略super.。
    当在构造器，或实例方法等当中，出现了“子类声明的成员变量”和“父类声明成员变量”重名时，才需要在父类声明的成员变量的前面加“super.”。（当然这种情况，是建议，强制要求大家要避免的）
    super.成员变量，一定是父类声明的成员变量（权限修饰符允许该成员变量在子类可见）。

（2）super.成员方法
    在子类中使用父类声明的成员方法（权限修饰符允许该成员变量在子类可见），如果该成员方法没有被“重写”，也可以通过super.成员方法进行访问，或者完成省略super.。
    如果该成员方法在子类“被重写了”，那么在子类中想要使用被重写的方法时，就“必须”加"super."。
    
    super.成员方法，一定去父类中找某个方法。
    
    super.成员变量和super.成员方法，如果在直接父类中没有找到，可以去间接父类找。

（3）super() 或 super(实例列表)
    A：它只能出现在子类构造器的首行
    B：它只能找直接父类的构造器，不会找到父类的父类中去。
```

#### 2.3 面试题中出现

（1）在构造器或非静态代码块、实例方法中，出现使用某个变量

```java
A：变量的前面没有"this."也没有"super."，从局部变量列表（当前要注意作用域）开始找，如果局部变量没有，再找到本类的成员变量列表，如果再没有，继续找到父类中（当然父类中的要求权限修饰符允许）

B：变量的前面有"this."，从本类的成员变量列表，如果没有，继续找到父类中（当然父类中的要求权限修饰符允许）
    
C：变量的前面有"super."，从直接父类的成员变量列表开始找，如果没有，继续往上（当然父类中的要求权限修饰符允许）
```

（2）在构造器或非静态代码块、实例方法中，出现使用某个方法

```java
A：方法的前面没有"this."也没有"super."，从本来的方法列表开始找，如果没有，到父类中找（当然父类中的要求权限修饰符允许）

B：方法的前面有"this."，从本来的方法列表开始找，如果没有，到父类中找（当然父类中的要求权限修饰符允许）
    
C：方法的前面有"super."，从直接父类的方法列表开始找，如果没有，继续往上（当然父类中的要求权限修饰符允许）
    

找到了，不见得就是执行这个方法，如果是this，那么要看当前this代表的是哪个类的对象，如果this是子类对象，并且子类进行了重写，会执行子类重写的方法体。    
```

#### 2.4 native

1、native的意思

```java
本地的
```

2、native用在哪里

```java
在方法的返回值类型前面
```

3、native修饰的方法有什么不同

```java
【修饰符】 class 类名{
	【其他修饰符】 native 返回值类型  方法名(【形参列表】);
}

native修饰的方法，它的方法体不在Java语言中，在C/C++底层的系统库中。
```

4、JVM的运行时内存

```java
（1）方法区：存储被加载的类等信息
（2）堆：存储用new关键字创建处理的对象，包括数组对象，和其他类的对象。
（3）Java虚拟机栈：存储Java的方法的局部变量列表等信息
（4）本地方法栈：存储native修饰的方法的局部变量等信息
（5）程序计数器：留到多线程再说    
```

5、native修饰的方法如何使用？

（1）如何调用

```java
和Java的其他方法一样调用。
不用管它是否是native方法，就当成是Java的方法用就可以了。很多时候，我们调用一个native时，不看源码的话，都不知道它是native的方法。
例如：
    Object类中 public native int hashCode();
    System类中 public static native long currentTimeMillis();
```

（2）是否可以被重写，以及如何被重写？

```java
是否能被重写，要看其他修饰符。如果native方法前面有private或static、final等，就不能被重写。
如果没有这些修饰符，可以被重写。
    
和重写其他Java的方法一模一样。即不用管它是不是native修饰的。
```

#### 2.5 final

1、意思

```java
最终的
```

2、final的三个用法

```java
（1）final修饰类，在class前面的：表示这个类不能被继承
（2）final修饰方法，在返回值类型前面：表示这个方法不能被重写，但是可以被继承，也可以重载。  
（3）final修饰变量，表示这个变量的值不能被修改。
   
  final修饰的成员变量必须手动初始化。
    A：在声明成员变量的后面直接加 " = 值;"
    B：在非静态代码块中给final修饰的成员变量初始化
    C：在构造器中给final修饰的成员变量初始化
    A，B，C只能选择一种给同一个final修饰的成员变量赋值。    
  final修饰的成员变量是没有set方法的。
```

## day13早上复习

### 1、Java的根父类Object类

#### 1.1 如何理解根父类的概念

```java
(1)所有类都会直接或者间接的继承Object类，包括数组类型
    Student、String
    int[]，Student[]
    都是Object类的子类
（2）所有类都会继承Object类的方法（一共有11个方法，昨天学习了5个）
（3）Object类型的变量，可以接收任意类型的对象
    Object 变量 = 任意类型的对象;
	Object[] 数组名 = {任意类型的对象，任意类型的对象,...};
Java规定：Object[] 可以接收任意的对象数组
    String[] strings = new String[5];
	Object[] arr = strings;
Java规定：Object[] 不可以接收元素是基本数据类型的一维数组
    int[] nums = {3,4,1,1,3};
	Object[] arr = nums;//错误  因为Object[]表示一组对象，int[]是一个数组对象

	int[][] two = {{1,2,3,3,4},{4,5,56,6},{5,6,6,6}};
    Object[] arr = two;//可以  因为二维数组可以看成元素是int[]的一维数组
（4）所有类的对象创建都会直接或间接的调用到Object类的无参构造
    一个类如果没有显式的用extends表名它的直接父类是谁，默认它的直接父类就是Object类，此时这个类的构造器中的super()就表示是Object类的无参构造。    
```

#### 1.2 Object类的常用方法（暂时列5个）

```java
public String toString()：
    A：没有重写的话，默认返回的是  对象的运行时类型全名称 @ 对象的hashCode值的无符号十六进制值形式
    B：当我们使用println等打印的方法打印/输出对象时，会自动调用这个对象的toString
    C：当我们把对象与字符串进行“+”拼接时，也会自动调用对象的toString
    D：toString()的重写可以选择Ctrl + O和Alt + Insert
    	Ctrl + O：通用的重写的快捷键，模板默认的是产生 return super.toString();
		Alt + Insert：产生基本Javabean的代码的快捷键，模板默认产生但是是  return 类名 + 各个实例变量值的拼接。
```

```java
public final Class<?> getClass()：
    A：作用是返回对象的“运行时”类型
    B：这个方法不能被子类重写，因为有final
    C：返回值是一个Class对象，它是代表对象的运行时类型
```

```java
public boolean equals(Object obj)：
    A：作用是用于当前类的对象 与 另一个对象 比较是否相等的作用。
    	正常的比较两个对象一定都是当前类的对象，才是有意义的。
    B：如果没有重写这个方法，默认从Object继承的是 和 “==”一样的，比较对象的地址值
    C：如果要重写的话，可以选择Ctrl + O和Alt + Insert
    	Ctrl + O：通用的重写的快捷键，模板默认的是产生 return super.equals(obj);
		Alt + Insert：产生基本Javabean的代码的快捷键，模板默认产生但是是 根据实例变量的值比较（同时还会考虑类型、空或非空等情况）
    D：如果要手动重写，要遵循几个原则：
            自反性：x.equals(x)是true
            对称性：x.equals(y) == y.equals(x)
            传递性：x.equals(y)是true,y.equals(z)是true，那么x.equals(z)一定是true
            一致性：x.equals(y)在前后的比较结果要一致，前提是x和y对象的属性没有改变的话
            非空对象与null一定返回false
```

```java
public native int hashCode()：
    A：作用是返回当前对象的一个哈希值，这个哈希值用于提高哈希表等的性能（只有当对象放到哈希表等结构中时才有意义，平时不用它）
    B：这个方法如果要重写，一把都是和equals方法一起重写的，因为必须保证如下常规协定的条件：
    ①两个对象如果equlas返回true，那么要求它俩的hashCode值一定相同
    ②两个对象如果hashCode值不相等，那么它俩调用equals方法一定返回false
    ③两个对象如果hashCode值相等，那么它俩调用equals方法可能是true，也可能是false
    	例如："Aa"和"BB”的hashCode值2112相同，但是它俩equals不相同
```

```java
protected void finalize()throws Throwable
    A：设计它的作用是为了能够让GC在回收当前对象时，让和当前对象相关的JVM以外的内存得到释放，即在finalize方法中，通常需要调用 底层C的释放内存的方法。
    B：设计它不能被调用2次的目的，是为了安全，避免出现僵尸对象。
    C：这个方法不用程序员手动调用，由GC调用。
```

### 2、静态

#### 2.1 static关键字可以用在哪些地方

```java
（1）可以修饰成员变量，不能修饰局部变量
（2）可以修饰成员方法，不能修饰构造方法（构造器）
（3）可以修饰代码块
（4）可以用于import语句，表示静态导入
    	import static 包.类名.静态成员名;
		import static 包.类名.*;
（5）后面还会学习一种，修饰成员内部类
```

#### 2.2 static修饰的变量有什么不同

```java
（1）static修饰的变量，称为静态变量，或者类变量，或者静态类变量
（2）静态变量的值是所有对象共享的，不是属于某个对象的，和对象无关，但是可以通过对象访问它，因为它属于类的，对象可以使用类中的所有东西。
（3）静态变量的值存储在方法区，和类信息在一起
（4）静态变量的get/set方法也是静态的
（5）当有变量与静态变量重名时，可以使用“类名.静态变量”来区别
（6）静态变量的初始化在类初始化时完成，一个类的初始化只会进行一次，如果后期需要修改静态变量的值，通常通过set方法
```

```java
静态变量、实例变量、局部变量的区别
（1）静态变量，有static修饰的成员变量，有默认值，所有对象共享，存储在方法区，生命周期是它们中最长的，和类的生命周期一样。访问它可以通过“类名.”，也可以通过“对象."，建议使用”类名."
（2）实例变量，没有static修饰的成员变量，有默认值，所有对象独立，存储在堆，生命周期和对象的生命周期一样。访问它只能通过“对象."
（3）局部变量，不能有static，权限修饰符等修饰，没有默认值，存储值在栈中，每一次方法调用都是独立的，注意有作用域。
```

#### 2.3 static修饰的方法有什么不同

```java
（1）static修饰的方法，称为静态方法，或者类方法
（2）在本类中，静态方法随意使用
（3）在其他类中，可以通过“类名.”，也可以通过“对象."，建议使用”类名."
（4）在静态方法中不允许出现 this, super, 本类的非静态成员的直接使用
（5）静态方法不能被子类重写，也没有多态现象，只看变量的编译时类型
（6）类中的静态方法可以被子类继承，即可以通过“子类名."方式调用
```

#### 2.4 static修饰的代码块有什么不同

```java
每一个类的静态代码块只运行一次，而且是在类初始化时就执行了
```

```java
类初始化：
（1）静态变量声明后面的显式赋值语句
（2）静态代码块
 同一个类（1）和（2）是按照编写的顺序执行

如果子类初始化时，发现父类还没有初始化，会先初始化父类，如果父类初始化过了，不会重复初始化父类。
类初始化一定是比实例初始化要早。
```

### 3、枚举

#### 3.1 枚举类的特点

```java
枚举类是一种特殊的类，它的对象是固定的有限的几个常量对象。
```

#### 3.2 枚举类的声明

```java
JDK1.5之前：
    （1）构造器私有化
    （2）用静态变量存储这几个常量对象
public class Season{
    public static final Season SPRING = new Season("春天");
    public static final Season SUMMER = new Season();
    public static final Season FALL = new Season();
    public static final Season WINTER = new Season();
    
    private String description;
	private Season(){}
    private Season(String description){this.description = description;}
}
```

```java
JDK1.5之后：
    （1）关键字 enum
    （2）构造器默认私有化
    （3）直接父类也是默认指定好的 java.lang.Enum类
    （4）常量对象列表必须在枚举类中代码的首行
    （5）如果常量对象列表后面没有其他代码，；可以省略，否则就不能省略
    （6）switch支持enum声明的枚举类型
```

```java
public enum Week{
    MONDAY,TUESDAY,WEDNESDAY,THURSDAY,FIRDAY,SATURDAY,SUNDAY
}
```

```java
public enum Week{
    MONDAY("星期一"), //表示调用有参构造 
    				//等价于 public static final Week MONDAY = new Week("星期一");
    TUESDAY,	//表示调用无参构造
    			//等价于 public static final Week TUESDAY = new Week();
    WEDNESDAY,THURSDAY,FIRDAY,SATURDAY,SUNDAY;
    
    private String description;
    Week(){
        
    }
    Week(String description){this.description = description;}
}
```

#### 3.3 常用API

（1）String name()：返回枚举对象的常量名

（2）int ordinal()：返回枚举对象的序号，从0开始

（3）static Week[]  values()：返回某个枚举类型的所有常量对象

（4）static Week valueOf(String name)：根据常量对象名称获取一个枚举常量对象

（5）String toString()：枚举类型中toString方法默认返回的是常量对象名称，子类可以重写。

## day14早上复习

### 1、包装类

#### 1.1 包装类型有哪些

```java
byte<-->Byte
short<-->Short
int<-->Integer
long<-->Long
float<-->Float
double<-->Double
char<-->Character
boolean<-->Boolean
void<-->Void
```

#### 1.2 装箱与拆箱

装箱：把基本数据类型的值转换为包装类的对象

拆箱：把包装类的对象转换为基本数据类型的值

```java
为什么要装箱？
    因为Java中很多API或新特性都是只针对对象来设计的，例如：集合、泛型等。
为什么要拆箱？
    因为Java中很多运算符都只支持基本数据类型的运算，不支持对象的运算。
```

```java
JDK1.5之后支持自动装箱与自动拆箱。
但是自动装箱与自动拆箱只能够   对应类型之间
```

#### 1.3 包装类的API

（1）获取某个类型的最大值/最小值：

```java
Integer.MAX_VALUE
Integer.MIN_VALUE
```

（2）基本数据与字符串之间的转换

```java
以int为例
    String str = "123";
	int num = Integer.parseInt(str);
	int num = Integer.valueOf(str);
	
	int a = 123;
	String string = a + "";
	String string = String.valueOf(a);
```

（3）字符转大小写

```java
以char为例
    char small = 'a';
	char big = (char)(small - 32);
	char big = Character.toUpperCase(small);

	char upper = 'A';
	char lower = (char)(upper + 32);
	char lower = Character.toLowerCase(upper);
```

（4）比较大小

``` java
以double为例
    double d1 = 3;
	double d2 = 2;
	
	if(d1>d2){
        System.out.println("d1>d2");
    }else if(d1 < d2){
        System.out.println("d1<d2");
    }else{
        System.out.println("d1=d2");
    }

	if(d1>d2){
        return 1;
    }else if(d1 < d2){
        return -1;
    }else{
        return 0;
    }

	return Double.compare(d1,d2);
```

#### 1.4 包装类的特点

（1）包装类对象不可变

（2）部分包装类有缓存对象

```java
Byte: -128 ~ 127
Short：-128 ~ 127
Integer：-128 ~ 127
Long：-128 ~ 127
    
Float和Double没有缓存对象。
    
Character：0-127
Boolean：true,false
```

### 2、抽象类

#### 2.1 抽象类的特点

（1）抽象类本身不能直接创建对象，只能创建它的子类对象

（2）抽象类有声明时有一个abstract修饰

（3）子类继承抽象类时，必须重写抽象父类的所有的抽象方法，当然如果子类也是抽象类的话，可以暂时不重写。

（4）抽象类中可以没有抽象方法，一定有构造器，可以有其他的成员变量（包括静态的、非静态的）、成员方法（包括静态、非静态等）、代码块（包括静态、非静态等）。

（5）如果某个类包含抽象方法，这个类必须是抽象类。

#### 2.2 抽象类和抽象方法的语法

```java
【public】 abstract class 类名{
    【权限修饰符】 abstract 返回值类型 方法名(【形参列表】);  //抽象方法没有方法体
}
```

### 3、接口

#### 3.1 如何声明接口

```java
【public】 interface 接口名{
    
}
```

#### 3.2 接口的成员有哪些？

（1）公共的静态的常量：public static final，这三个单词可以省略。

（2）公共的抽象方法：public abstract，这两个单词可以省略。

（3）公共的静态方法（JDK1.8之后）：public static，其中static不能省略，public可以省略

（4）公共的默认方法（JDK1.8之后）：public default，其中default不能省略，public可以省略

（5）私有方法（JDK1.9之后）：private，不能省略

#### 3.3 接口的成员要注意哪些？

（1）公共的静态的常量

- 在接口的外面使用：接口名.常量名
- 在接口的实现类中使用：如果没有重名问题，直接使用，不需加“接口名.”，如果有重名问题，必须加“接口名.常量名”

（2）公共的抽象方法

实现类实现接口时，必须重写接口的抽象方法。除非实现类是一个抽象类，可以暂时不重写。

（3）公共的静态方法

接口中的静态方法是==不会==继承到实现类中。当然也就不存在“重写”静态方法。

接口中的静态方法的使用方式只有一种：接口名.静态方法。

（4）公共的默认方法

- 实现类会继承接口的默认方法。而且实现类可以选择重写接口的默认方法，实现类重写时，default单词去掉。
- 如果实现类在继承父类和实现父接口时，出现默认方法冲突问题，如果没有处理，默认是选择的父类的。如果此时实现类想要选择父类或父接口中的实现，可以：
  - 父类：super.方法
  - 父接口：接口名.super.方法
- 如果实现类同时实现多个接口时，出现默认方法冲突问题，必须处理，要指定选择哪一个，还是完全重写。
  - 父接口：接口名.super.方法

#### 3.4 接口的特点

（1）接口类型本身是不能直接创建对象的，只能创建它的实现类对象。

（2）接口中是没有构造器，代码块等其他成员，除了上面的几种可以。

（3）实现类实现接口时，必须重写接口的抽象方法。除非实现类是一个抽象类，可以暂时不重写。

（4）实现类在实现接口时，支持多实现。

（5）子接口在继承父接口时，支持多继承。

```java
类  extends 父类   单继承
类  implements 父接口们  多实现
接口 extends 父接口们 多继承
```

#### 3.5 经典接口

1、java.lang.Comparable接口：自然排序/比较接口

2、java.util.Comparator接口：定制排序/比较接口

|                      | java.lang.Comparable接口                                     | java.util.Comparator接口                                     |
| -------------------- | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 称呼                 | 自然排序/比较接口                                            | 定制排序/比较接口                                            |
| 抽象方法             | int compareTo(Object obj)                                    | int compare(Object o1 ,Object o2)                            |
| 抽象方法返回值（int) | 第一个对象 大于 第二个对象 返回正整数、第一个对象 小于 第二个对象 返回负整数、第一个对象 等于 第二个对象 返回0 | 第一个对象 大于 第二个对象 返回正整数、第一个对象 小于 第二个对象 返回负整数、第一个对象 等于 第二个对象 返回0 |
| 使用                 | 要比较大小的对象类型本身实现这个接口                         | 在要比较大小的对象类型之外定义一个新的类实现这个接口         |
| 选择                 | 默认排序（优先选择它）                                       | 对Comparable比较器的补充，定制化的要求                       |

3、java.lang.Cloneable接口

什么情况下会使用它？当某个类的对象需要“克隆/复制”时，那么这个类需要实现这个接口。

此时还需要重写java.lang.Object类中：protected Object clone() throws CloneNotSupportedException，重写时，需要修改protected为public，调用这个方法时，需要对clone方法可能抛出的不支持可能异常进行处理。

4、java.lang.Iterable接口

什么情况下会使用它？

（1）数组类型默认都已经实现了这个接口

（2）像集合等容器类如果想要支持"foreach"语法，就要实现这个接口。

换句话说，凡是实现了Iterable接口的实现类对象，都支持foreach循环。



## day15早上复习

### 1、foreach循环

#### 1.1 语法格式

```java
for(元素的类型 元素的临时名 : 数组名或容器对象名){
    //对元素进行操作
}
```

#### 1.2 普通for循环和增加for循环（foreach）区别

（1）普通for循环不仅限于遍历数组等，而增强for循环只能用来遍历元素（数组或容器对象的元素）。

（2）普通for循环在遍历数组等元素时，是有“下标”信息的，而增强for循环是没有下标信息的。

```java
    public static void main(String[] args) {
        int[] arr = {3,5,2,1,4};

        for (int i = 0; i < arr.length; i++) {
            System.out.println(arr[i]);
        }

        for (int num : arr) {
            System.out.println(num);  //num 等价于上面的 arr[i]
        }
    }
```

（3）普通for循环中，通过数组名加[下标]可以直接修改元素的值。而增强for循环通过临时变量是无法直接修改元素的值。当然可以修改元素对象的属性值，只要不是让临时变量指向新的元素对象即可。



如何选择？

- 如果只是查看元素的值，那么增强for循环更简洁一点。
- 如果要体现下标信息，那么只能使用普通for循环。
- 如果要直接修改元素值，那么也只能使用普通for循环。
- 如果是非数组这种有下标信息的容器对象的遍历，也只能使用增加for循环。

总结：有下标信息，并且要修改元素的，就用普通for循环，其他都用增强for循环。



### 2、内部类

定义在另一个类里面的类叫做内部类。

#### 2.1 内部类形式

形式有四种：

- 静态成员内部类：方法体外面
  - 只有静态内部类才能定义自己的静态成员，其他三种内部类都不允许定义自己的静态成员
- 非静态成员内部类：方法体外面
- 局部内部类：方法体里面
- 匿名内部类：在new对象的位置

#### 2.2 静态内部类和非静态内部类的区别

|          |                                      | 静态内部类                                      | 非静态内部类                                            |
| -------- | ------------------------------------ | ----------------------------------------------- | ------------------------------------------------------- |
| 类角色   | 字节码文件                           | 外部类名$内部类名                               | 相同                                                    |
|          | 修饰符                               | public，缺省，abstract，final                   | 相同                                                    |
|          | 父类或父接口                         | 可以                                            | 相同                                                    |
|          | 可以包含的成员                       | 所有成员                                        | ==不允许有静态成员==                                    |
| 成员角色 | 修饰符                               | public、protected、缺省、private，final，static | public、protected、缺省、private，final，==没有static== |
|          | 依赖于外部类                         | 依赖                                            | 相同                                                    |
|          | 依赖于外部类的对象                   | 不依赖                                          | ==依赖==                                                |
| 使用     | 在外部类中使用内部类                 | 没有限制                                        | 在外部类的静态方法等中不能使用非静态内部类              |
|          | 在内部类中使用外部类                 | 静态内部类中不能使用外部类的非静态成员          | 没有限制                                                |
|          | 在外部类的外面使用内部类的静态成员   | 外部类名.静态内部类名.静态成员                  | ==**没有静态成员**==                                    |
|          | 在外部类的外面使用内部类的非静态成员 | 见下面的框1                                     | 见下面的框2                                             |
| 重名     |                                      | 外部类名.重名的成员名                           | 外部类名.this.重名的成员                                |

```java
外部类名.静态内部类名 变量 = 外部类名.静态内部类名();
变量.非静态成员();
```

```java
外部类名 变量1 = new 外部类();
外部类名.非静态内部类名 变量 = 变量1.new 非静态内部类名();
变量.非静态成员();
```



#### 2.3 成员内部类和局部内部类的区别

|              |                                | 成员内部类                                                   | 局部内部类                                                   |
| ------------ | ------------------------------ | ------------------------------------------------------------ | ------------------------------------------------------------ |
| 类角色       | 字节码文件                     | 外部类名$内部类名                                            | 外部类名$==编号==内部类名                                    |
|              | 修饰符                         | public，缺省，abstract，final                                | abstract，final                                              |
|              | 父类或父接口                   | 可以                                                         | 可以                                                         |
|              | 可以包含的成员                 | 只有静态内部类才能有静态成员，非静态成员都可以               | 非静态成员都可以                                             |
| 成员局部角色 | 修饰符                         | public、protected、缺省、private，final，static              | final                                                        |
|              | 依赖于外部类                   | 依赖                                                         | 依赖                                                         |
|              | 依赖于外部类的对象             | 静态内部类不依赖，非静态内部类依赖                           | 局部内部类所在方法是静态方法就不依赖，是非静态方法就依赖     |
| 使用         | 在外部类中使用内部类           | 静态的成员不能直接使用非静态的成员                           | 有作用域，仅限于所在方法使用                                 |
|              | 在内部类中使用外部类           | 静态的成员不能直接使用非静态的成员。外部类的静态成员都可以使用。静态内部类中不允许使用外部类的非静态成员，非静态内部类中可以使用外部类的非静态成员。 | 静态的成员不能直接使用非静态的成员，局部内部类是在静态方法中，就不能使用外部类的非静态成员，局部内部类在非静态方法中，就可以使用外部类的非静态成员。外部类的静态成员都可以使用。 |
|              | 在外部类的外面使用内部类       | 可以用。使用静态成员，就外部类名.静态内部类名.静态成员即可。使用非静态成员，对于静态内部类来说，只要创建静态内部类的对象即可，对于非静态内部类来说，需要先创建外部类的对象，再创建非静态内部类的对象才能使用。 | 不可以                                                       |
|              | 在内部类中使用外部类的局部变量 | 不可以                                                       | 可以使用所在方法的局部变量，但是有要求，必须是final的局部变量。JDK1.8之前必须手动加final，JDK1.8之后自动加final。 |
| 重名         |                                | 和外部类的静态成员重名，就用外部类名.静态成员。和外部类的非静态成员重名，就用外部类名.this.非静态成员名。 | 相同                                                         |

## day16早上复习

### 1、匿名内部类

匿名内部类是一种特殊的局部内部类。

匿名内部类是声明形式非常特殊，它是一边声明类一边创建这个类的唯一对象。

```java
形式一：
    new 父类(){   //表示指定了匿名内部类的直接父类，并且明确了调用直接父类的无参构造
    	类的成员
	}
形式二：
    new 父类(实参列表){   //表示指定了匿名内部类的直接父类，并且明确了调用直接父类的有参构造
    	类的成员
	}
形式三：
    new 父接口(){   //表示指定了匿名内部类实现的接口，并且它的直接父类是Object，明确了调用直接父类的无参构造
    	类的成员
	}
```

匿名内部类的使用：

```java
使用形式一：
    匿名内部类的匿名对象直接调用方法。
    new 父类/父接口(【实参列表】){
		方法
	}.方法(【实参列表】);

使用形式二：
    使用匿名内部类的父类或父接口的变量 接收 匿名内部类的的对象。
    父类/父接口 变量 = new 父类/父接口(【实参列表】){
		方法1
        方法2
	};
	变量.方法1(【实参列表】);
	变量.方法2(【实参列表】);
使用形式三：
    把匿名内部类的匿名对象作为另一个方法调用的实参。
    
    方法(new 父类/父接口(【实参列表】){
		方法
	});
```

### 2、注解

注解是一种代码级别的注释，注解是要被另一段程序（编译器，其他的Java程序）读取，并处理的注释。

```java
@Override：由编译器来读取，读取到某个方法上面加了@Override，就会对这个方法进行“严格”的检查，必须满足重写的所有要求。
@Deprecated：标记什么方法、类已过时
@SuppressWarnings：抑制警告
```



### 3、JUnit

它本质上是一个单元测试工具，目前我们只是把它当成一个代替main方法的测试运行工具。

@Test注解，它标记的方法，表示可以独立运行。

@Test注解标记的方法：

```java
这个类必须是public，而且必须只有唯一的无参构造。
这个方法本身必须是public、void、()，非静态的方法。
```

使用它之前需要先引入JUnit的库。





### 4、异常

#### 4.1 异常的类型

异常的根类型：java.lang.Throwable类型。它有两大子类：Error和Exception。

- Error：是指严重的错误，不应该使用try...catch处理，而应该停下来修正程序或升级硬件。
- Exception：是指合理的应用程序需要避免或处理的异常类型。它有分为两大类：
  - 运行时异常（非受检异常，即编译器检测不到）：RuntimeException及其子类。
  - 编译时异常（受检异常，编译器会提醒你可能发生xx异常，不表示一定发生）：无论是否发生都要提前编写异常处理代码，否则编译不通过。异常中除了运行时异常剩下的都是编译时异常。

面试题：列出你在开发过程中经常/曾经遇到的异常类型（至少5种）。

```java
ArrayIndexOutOfBoundsException：数组下标越界异常
NullPointerException：空指针异常
ClassCastException：类型转换异常
ArithmeticException：算术异常
InputMismatchException：输入不匹配异常
NumberFormatException：数字格式化异常
....
```

面试题：列出你在开发过程中经常/曾经遇到的错误类型。

```Java
OutOfMemoryError：OOM，堆内存溢出
StackOverflowError：栈内存溢出
```

面试题：请编写一段代码演示xx异常/错误。

```java
OutOfMemoryError:
 	public static void main(String[] args) {
        int[] arr = new int[Integer.MAX_VALUE];
    }
StackOverflowError：栈内存溢出
    @Test
    public void test1(){
        test1();
    }
```





#### 4.2 异常相关的5个关键字

try,catch,finally,throws, throw

```java
try{
    可能发生异常的代码
}catch(异常类型1 参数名){
	异常处理的代码或异常打印代码
}catch(异常类型2 参数名){
	异常处理的代码或异常打印代码
}
```

执行特点：

（1）try{}中没有发生异常，一个catch都不会执行

（2）try{}中有异常发生，try{}中发生异常的代码剩下的代码都不执行，去找匹配的catch分支，从上往下找匹配的catch，如果上面有一个catch匹配了，下面的catch就不看了。只会进入一个catch分支。只要找到一个catch分支，相当于异常被处理了，代码继续运行try...catch结构下面的代码。

（3）try{}中有异常发生，但是所有catch都不匹配，相当于异常没有处理，自动抛出上级。如果上级也不处理，继续往上抛，直到main方法，如果main方法也不处理，程序就挂了。

```java
try{
    可能发生异常的代码
}finally{
    必须执行的代码
}

try{
    
}catch(异常类型1 参数名){
	异常处理的代码或异常打印代码
}catch(异常类型2 参数名){
	异常处理的代码或异常打印代码
}finally{
    必须执行的代码
}
```

- 无论try中是否发生异常，finally都要执行。
- 无论catch是否可以捕获异常，finally都要执行。
- 无论try或catch分支中是否有return语句，finally都要执行。
- 如果finally块中也有return语句，会导致try或catch中的return语句的结果无法返回。
- finally块通常是编写资源释放的代码。

throws和throw的区别：

- throws只能出现在方法()后面，表示当前方法没有处理这个异常，需要调用者处理这个异常。
- throw只能出现在方法体里面，表示在xx条件下手动抛出一个异常的对象。只要有throw语句，就表示当前方法可能发生xx异常。如果这个异常对象的类型是运行时异常类型，那么编译器不会提示你要做什么处理。但是如果这个异常对象是编译时异常类型，那么编译器会强制你处理这个异常，处理方式有两种，一种是throws甩给调用者处理，一种是try...catch处理，编译才会通过。

```java
【修饰符】返回值类型 方法名(【形参列表】)throws 异常类型列表{ //如果异常类型列表有多个类型，可以用逗号分隔
    
    if(){
        throw new 异常类型(【实参类别】);
    }
}
```

#### 4.3 自定义异常

要求：

（1）自定义异常是一个“类class”，==必须==继承Throwable或它的子类。一般是继承如下两个类：

- RuntimeException：如果是继承它，那么说明你这个自定义异常是运行时异常
- Exception：如果是继承它，那么说明你这个自定义异常是编译时异常。如果是这种，一旦方法体中有throw new 自定义异常类型()的代码，就必须加throws或try...catch，否则编译不通过。

（2）建议自定义异常编写两个或以上的构造器

```java
自定义异常类型(){//无参构造
	
}
自定义异常类型(String message){//无参构造
	super(message);
}
```

（3）自定义异常的对象，必须使用throw语句抛出。

#### 4.4 方法重写

要求：

（1）方法名：必须相同

（2）形参列表：必须相同

（3）返回值类型

​	基本数据类型和voie：必须相同

​	引用数据类型：<=

（4）权限修饰符：>=

被重写方法不能是private，跨包不能是缺省

（5）其他修饰符

不能是final，static

（6）throws的要求

- 如果被重写方法没有throws编译时异常，那么重写方法时，也不能throws编译时异常。
- 如果被重写方法有throws编译时异常，那么重写方法时，可以不throws编译时异常，如果要throws编译时异常，也只能是<=的关系。
- 重写方法对于运行时异常不做任意要求，因为编译时不会检查运行时异常。

## day17早上复习

### 1、JavaSE实现多线程的两种方式

```java
（1）继承Thread类
 步骤：
    匿名或有名的类继承Thread类
    重写public void run()方法
    创建Thread子类的对象
    调用对象的start()方法
（2）实现Runnable接口
步骤：
    匿名或有名的类实现Runnable接口
    重写public void run()方法
    创建Runnable实现类的对象
    创建Thread类的对象，把Runnable实现类的对象作为Thread构造器的实参
    调用Thread类对象的start()
```

### 2、Thread类的一些方法：

- public String getName()：获取当前线程的名称。
- public static Thread currentThread()：返回当前正在执行的线程的引用/对象。
- public int getPriority()：返回当前线程的优先级
- public void setPriority(int level)：设置优先级，优先级的范围是[1-10]。
- public static void sleep(long time)：当前线程休眠。
- public static void yield()：让当前线程暂停。让线程调度器重新调度，让其他线程争取机会。
- public void join()：让正在执行这句代码的当前线程终止。
- public void join(long time)：让正在执行这句代码的当前线程终止time毫秒。
- public void stop()：停止当前线程。已过时。

### 3、线程安全问题

（1）什么情况下会有线程安全？如何判断？

- 有共享资源
- 有多个线程
- 有读有写操作

（2）如何解决线程安全问题？JavaSE阶段，synchronized

- 同步方法
- 同步代码块

（3）同步锁是谁？如何选择？

同步锁对象可以是任意类型，但是要求具有竞争关系的多个线程必须使用同一个锁对象。

同步方法：

- 静态方法：默认就是当前类的Class对象
- 非静态方法：默认就是this

同步代码块的锁对象是可以手动选择的。

（4）同步锁的原理

同步锁对象的对象头中有一个锁的标记位，记录当前哪个线程占用锁对象。

### 4、线程通信

（1）线程通信依赖哪些方法？

- wait()
- notify()/notifyAll()

这些方法在哪个类中定义的？Object类中。

这个方法要由谁调用？同步锁对象调用。如果不是同步锁对象调用，会报IllegalMonitorStateException非法监视器对象异常。==>wait()和notify()/notifyAll()必须出现在同步方法或同步代码中。

（2）线程通信应用场景，解决什么问题？

生产者和消费者问题。

问题描述：多个线程使用共享数据，而且这个共享数据是具有一定缓存空间的的数据，当一个（一些）线程负责往这个缓冲区中“增加/填充”数据，而另一个（一些）线程是负责从这个缓冲区“消耗/取走”数据，那么把往里增加数据的线程称为生产者，把往外取数据的线程称为消费者。因为不可能无限的往里填充数据，也不能无条件的往外取数据，那么就会出现，当缓冲区满的时候，生产者线程需要wait，当缓冲区空的时候，消费者线程需要wait。wait有两种情况，一种是不限时的wait，直到有其他线程notify唤醒它，另一种是限时wait，到时间之后或有人notify它都会被唤醒。

notify：唤醒正在等待的其中一个线程。

notifyAll：唤醒所有等待的线程。确认哪些线程会被唤醒，和锁对象有关，由它监视的线程才会被唤醒。
