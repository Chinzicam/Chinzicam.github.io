---
title: 软件工程与UML
author: 橙子草草
date: 2022-12-11 10:40:40
tags:
- 软件工程
categories: 
- 学习笔记
cover: true
sidebar: [blogger, category, toc] # 放置任何你想要显示的侧边栏部件
headimg: 
---

## 软件工程

### 第1章  **软件工程学概述**

软件是程序+数据+文档

### 1.1 软件危机

#### 软件危机的典型表现：

**（1）对软件开发成本和进度的估计常常很不准确**

**（2）用户对“已完成的”软件系统不满意的现象经常发生；**

**（3）软件产品的质量往往靠不住；**

**（4）软件常常是不可维护的；**

（5）软件通常没有适当的文档资料；

（6）软件成本在计算机系统总成本中所占的比例逐年上升；

（7）软件开发生产率提高的速度，远远跟不上计算机应用迅速普及深入的趋势 。

#### 产生软件危机的原因

- 开发方法不正确有关
- 轻视软件维护

### 1.2 软件工程

#### 软件工程的基本原理

- 用分阶段的生命周期计划严格管理

-  坚持进行阶段评审

- 实行严格的产品控制

- 采用现代程序设计技术

-  结果应能清楚地审查

- 开发小组的人员应该少而精

- 承认不断改进软件工程实践的必要性

#### 面向对象方法学的优点：

- 模拟人类习惯的思维方式

- 主动地多次反复迭代

- 软件的重用

### 1.3 软件生命周期

![](软件工程与UML/1.png )

**问题定义**：了解用户的问题是什么

> 结果：**系统规模和目标的报告书**

**可行性研究**：讨论这个问题是否有可行性的解

> 结果：**数据流图、可行性论证报告**

**需求分析**：讨论系统需要完成那些功能

> 结果：**细化的数据流图、规格说明书**

**总体设计**：把系统的层次设计出来，就是把系统的模块设计出来

> 结果：**层次图、模块结构**

**详细设计** ：怎么实现系统

> 结果：**算法和数据结构**

**编码测试**：

> 结果：**代码和测试报告**

**综合测试**：集成，放在用户的系统里进行测试

**软件维护**：四种维护（改正性维护、改正性维护、完善性维护、预防性维护）

> 结果：**完整的维护记录**

### 1.4 软件过程（五种软件过程）

#### **瀑布模型**

1. 顺序性和依赖性

2. 推迟实现的观点

3. **以是“文档驱动”的模型；**

![2](软件工程与UML/2.png)

#### **快速原型模型**

快速建立起可以运行的程序

#### **增量模型**

慢慢增加开发人员的数量

![3](软件工程与UML/3.png)

#### **螺旋模型**

以风险驱动

![](软件工程与UML/4.png)

![5](软件工程与UML/5.png)

#### **喷泉模型**

以对象为驱动

![6](软件工程与UML/6.png)

## 第2章 可行性研究

### **2.1** **可行性研究的任务**

#### **主要方面：**

1. 技术可行性，使用现有的技术能实现这个系统吗?
2. 经济可行性，这个系统的经济效益能超过它的开发成本吗?
3. 操作可行性，系统的操作方式在这个用户组织内行得通吗?

### **2.4** **数据流图**

先总后分

![7](软件工程与UML/7.png)

![8](软件工程与UML/8.png)

#### 三个例子

![55](软件工程与UML/55.png)

![56](软件工程与UML/56.png)

![57](软件工程与UML/57.png)

![58](软件工程与UML/58.png)

![59](软件工程与UML/59.png)

![60](软件工程与UML/60.png)

![61](软件工程与UML/61.png)

![62](软件工程与UML/62.png)

![63](软件工程与UML/63.png)

![64](软件工程与UML/64.png)

![65](软件工程与UML/65.png)

![66](软件工程与UML/66.png)

![67](软件工程与UML/67.png)

![68](软件工程与UML/68.png)

![69](软件工程与UML/69.png)

![70](软件工程与UML/70.png)

![71](软件工程与UML/71.png)

![72](软件工程与UML/72.png)

### **2.5** **数据字典**

#### **数据字典的组成：**

- **数据流**
- **数据流分量**(即数据元素)
- **数据存储**
- **处理**(用其它工具描述更方便，如IPO图)

![9](软件工程与UML/9.png)

![10](软件工程与UML/10.png)

### **2.6** 成本/效益分析

工作量：用人月或人年，需要5人3月=15，

## **第3章 需求分析**（得到软件需求规模书）

完成功能和软件的性能，软件的接口

### **需求分析的任务**

要完成系统要做什么，完成什么

- 需求分析是软件定义时期的最后一个阶段，它的基本任务是准确地回答“系统必须做什么?这个问题。
- 确定系统必须完成哪些工作，也就是对目标系统提出完整、准确、清晰、具体的要求。
- 系统分析员应该写出软件需求规格说明书，以书面形式准确地描述软件需求。

### 需求分析对系统的综合要求

1. **功能需求**

2**. 性能需求**

3. 可靠性和可用性需求

4. 出错处理需求

5. **接口需求**

6. 约束

7. 逆向需求

8. 将来可能提出的要求

![11](软件工程与UML/11.png)

**状态图就是uml中的状态转化图**

### **层次方框图**（描述数据结构图）（里面的矩形表示数据）

描述数据结构

![11](软件工程与UML/11.png)

![15](软件工程与UML/15.png)

后期会和状态图、Jackson图进行对比

### **从哪些方面验证软件需求的正确性**

- **一致性**，所有需求必须是一致的，任何一条需求不能和其他需求互相矛盾。
- **完整性**，需求必须是完整的，规格说明书应该包括用户需要的每一个功能或性能。
- **现实性**，指定的需求应该是用现有的硬件技术和软件技术基本上可以实现的 。
- **有效性**，必须证明需求是正确有效的，确实能解决用户面对的问题。

## **第5章 总体设计**（是对模块的设计，没有涉及到算法）

**制定测试计划、用户手册、数据库设计结果（ER图是数据库的概念模型，在需求分析中产生的）是在总体设计的产物**

### 为什么要模块呢

软件本身是比较复杂的，功能有比较多，把它模块之后比较容易理解

![13](软件工程与UML/13.png)

### 模块化的两个指标（*模块独立程度的两个定性标准度量：*

**耦合**衡量不同模块彼此间互相依赖(连接)的紧密程度。

**内聚**衡量一个模块内部各个元素彼此结合的紧密程度。

### 六种耦合

- **非直接耦合/完全独立**：模块之间完全独立

- **数据耦合**：两个模块之间只进行数据交换（**数据耦合是理想的目标。**）

- **控制耦合**：两个模块之间有传递控制信息（控制耦合往往是多余的，把模块适当分解之后通常可以用数据耦合代替它。）

- **特征耦合**：一个模块作为参数被另一个模块调用（有被计算机犯罪提供机会）

- **公共环境耦合**：两个或多个模块通过一个公共数据环境相互作用时

- **内容耦合**：（**最高程度的耦合是内容耦合。**）

  - **一个模块访问另一个模块的内部数据；**
- **一个模块不通过正常入口转到另一个模块的内部；**
  - **两个模块有一部分程序代码重叠；**
- **一个模块有多 个入口。** 
  - 代码重叠是内容耦合

  **耦合是影响软件复杂程度的一个重要因素。**

  **应该采取下述设计原则：**

  ​     **尽量使用数据耦合，**

  ​     **少用控制耦合和特征耦合，**

  ​     **限制公共环境耦合的范围，
  ​    完全不用内容耦合。** 

### 七种内聚

- **偶然内聚**：在一个模块中完成一组任务，当这些任务关系很松散
- **逻辑内聚**：一个模块完成的任务在逻辑上属于相同或相似的一类
  - （接口难以理解，造成整体上不易理解；完成多个操作的代码互相纠缠在一起，即使局部功能的修改有时也会影响全局，导致严重的维护问题；难以重用。）
- **时间内聚**：一个模块包含的任务需要在同一个时间段完成
  - 时间关系在一定程度上反映了程序某些实质，所以时间内聚比逻辑内聚好一些。模块内操作之间的关系很弱，与其他模块的操作却有很强的关联。时间内聚的模块不太可能重用。
- **过程内聚**：一个模块内需要处理的元素是相关联的，而且需要按一定次序执行
  - 比时间内聚好，至少操作之间是过程关联的。仍是弱连接，不太可能重用模块。
- **通信内聚**：一个模块使用同一个输出或产生同一个输出数据，同一个数据结构上操作。
  - 模块中各操作紧密相连，比过程内聚更好。不能重用。
- **顺序内聚**：一个模块处理元素和一个功能密切相关，而且必须按顺序执行
  - 根据数据流图划分模块时，通常得到顺序内聚的模块，这种模块彼此间的连接往往比较简单。
- **功能内聚**：模块内所有处理元素属于一个整体，完成一个单一功能，
  - **功能内聚是最高程度的内聚。**
  - 模块可重用，应尽可能重用；可隔离错误，维护更容易；扩充产品功能时更容易。



### **模块规模应该适中**，在50~100行语句，最多不超过500行

### **深度、宽度、扇出和扇入**

![14](软件工程与UML/14.png)

下面是层次图，软件结构图，矩形是模块，连线为调用关系

![15](软件工程与UML/15.png)

### **模块的作用域应该在控制域之内**

**模块的作用域**：定义为受该模块内一个判定影响的所有模块的集合。

**模块的控制域**：是这个模块本身以及所有直接或间接从属于它的模块的集合。

![16](软件工程与UML/16.png)

![17](软件工程与UML/17.png)

### 三种图比较

<img src="软件工程与UML/18.png" alt="18"  />

![28](软件工程与UML/28.png)

###  **面向数据流的设计方法**

#### **信息流有两种类型：**

**变换流**

**事务流**

## 第6章 详细设计（编码之前的算法设计和程序的结构设计）

程序流程图、PAD图、盒图

### **人机界面设计**

完成一个界面的规划和颜色的搭配

#### **设计人机界面过程中会遇到的4个问题：**

系统响应时间

用户帮助设施

出错信息处理

命令交互

### 三个图只要看懂PPT上的一个例子

![19](软件工程与UML/19.png)

![20](软件工程与UML/20.png)

![21](软件工程与UML/21.png)

### **判定表**和判断树

![22](软件工程与UML/22.png)

![23](软件工程与UML/23.png)

![24](软件工程与UML/24.png)

![25](软件工程与UML/25.png)

![26](软件工程与UML/26.png)

![27](软件工程与UML/27.png)

### **过程设计语言**(PDL语言)

就是伪代码

### **Jackson**图

![28](软件工程与UML/28.png)

### **程序复杂程度**

环形复杂度等于测试路径数量

![29](软件工程与UML/29.png)

<img src="软件工程与UML/32.png" alt="32" style="zoom: 50%;" /><img src="软件工程与UML/30.png" alt="30" style="zoom: 50%;" /><img src="软件工程与UML/31.png" alt="31" style="zoom: 50%;" />

## **第7章 软件实现**

![33](软件工程与UML/33.png)

### 编码的规范（编码的风格）

恰当的标识符

适当的注解

程序的视觉组织’

### 软件测试的目标

- 测试是为了发现程序中的错误而执行程序的过程
  - 发现软件所有的错误，这句话是错的，只能发现绝大部分错误
- 好的测试方案是极可能发现迄今为止尚未发现的错误的测试方案；
- 成功的测试是发现了至今为止尚未发现的错误的测试。

### **软件测试准则**

所有测试都应该能追溯到用户需求；

应该远在测试开始之前就制定出测试计划；

应该从“小规模”测试开始，并逐步进行“大规模”测试；

穷举测试是不可能的；

为了达到最佳的测试效果，应该由独立的第三方从事测试工作。

### **测试方法**

黑盒和白盒的划分依据（对里面的代码是否了解）

下面的表格看一下

![34](软件工程与UML/34.png)

### 测试步骤

模块测试(单元测试)

子系统测试

系统测试

验收测试(确认测试)

平行运行

### 回归测试

修改了软件之后，重新测试

#### **Alpha和Beta测试**（测试的场所）

Alpha测试由用户在开发者的场所进行

Beta测试是在客户的环境进行测试

### 测试总结

![35](软件工程与UML/35.png)

### 白盒测试分几种覆盖

语句覆盖

判定覆盖

条件覆盖

判定/条件覆盖

条件组合覆盖

### 点、边、路径覆盖

![36](软件工程与UML/36.png)

### 测试路径

![38](软件工程与UML/38.png)
![39](软件工程与UML/39.png)
![37](软件工程与UML/37.png)

### 黑盒测试（等价划分和边界值）

#### 等价划分例题

![40](软件工程与UML/40.png)

![41](软件工程与UML/41.png)

![42](软件工程与UML/42.png)

![43](软件工程与UML/43.png)

![44](软件工程与UML/44.png)

![45](软件工程与UML/45.png)

#### 边界值

100的边界值，整数就是99和101，小数就99.9和100.1

### **调试是在测试发现错误之后排除错误的过程。**

### **软件可靠性**（两个指标）

平均维修时间MTTR

平均无故障时间MTTF

## **第8章 维护** 

### 四种维护

1. **改正性维护** 
   - 诊断和改正错误
2. **适应性维护** 
   - 因为环境的改变，为了与环境相适应而进行的修改
   - 为了和变化了的环境适当地配合而进行的修改
3. **完善性维护** 
   - 满足用户提出的新要求或对已有的功能进行修改
4. **预防性维护** 
   - 主动地进行重新设计、编码和测试。

### 维护的饼图

完善性维护占比最大，预防性最小，生命周期中软件维护占比最高

![46](软件工程与UML/46.png)

### 决定软件可维护性的因素

1. 可理解性
2. 可测试性
3. 可修改性
4. 可靠性
5. 可移植性
6. 可使用性
7. 效率

## **第9章** **UML统一建模语言** 

统一建模语言(UML)是一种绘制软件蓝图的标准语言。可以用UML对软件密集型系统的制品进行可视化详述和文档化。UML是一种定义良好、易于表达、功能强大且普遍适用的可视化建模语言。它融入了软件工程领域的新思想、新方法和新技术。它的作用域不限于支持面向对象的分析与设计，还支持从需求分析开始的软件开发的全过程。UML的作用就是用很多图从静态和动态方面来全面描述我们将要开发的系统。



统一建模语言(UML)是一种绘制软件蓝图的标准语言。UML是一种定义良好、易于表达、功能强大且普遍适用的可视化建模语言。它融入了软件工程领域的新思想、新方法和新技术。

UML的作用就是用很多图从静态和动态方面来全面描述我们将要开发的系统。

### uml中九种图

用例图，类图，对象图，状态图，活动图，时序图，协作图，构件图，部署图。外加包图。

### **用例图**

定义：由参与者（Actor）、用例（Use Case）以及它们之间的关系构成的用于描述系统功能的图成为用例图。

作用：用例图是从软件需求分析到最终实现的第一步，它显示了系统的用户和用户希望提供的功能，有利于用户和软件开发人员之间的沟通。用例图可视化的表达了系统的需求，具有直观、规范等优点，克服了纯文字性说明的不足。用例方法是完全从外部来定义系统的，它把需求和设计完全分离开来，使用户不用关心系统内部是如何完成各种功能的。

![47](软件工程与UML/47.png)

#### 四种关系

- 人和用例是**关联**
- 人和人是**泛化**
- 用例和它必须要实现的功能是**包含**
- **扩展**说可做可不做

### 类图

### **对象图**

#### 活动图和对象图（都是描述对象的行为）

活动图的一些符号

![48](软件工程与UML/48.png)

下面的框框就是泳道

![49](软件工程与UML/49.png)

### **时序图**（**顺序图，序列图**）（时间顺序）

生命线、被激活了

![50](软件工程与UML/50.png)

![51](软件工程与UML/51.png)

### 协作图（可以由时序图来生成）（空间结构顺序）

![52](软件工程与UML/52.png)

### **构件图**

![53](软件工程与UML/53.png)

### **部署图**

![54](软件工程与UML/54.png)

### 总结

UML提供了一系列的图来支持面向对象的分析与设计，

其中**类图**是面向对象系统规模中**最常用的图**，用于说明**系统的静态设计视图**；

当需要说明**系统的静态实现视图**时，应该选择**组件图**；

当需要说明**体系结构的静态实施视图**时，应该选择**部署图**。

**用例图**对系统的行为进行**组织和建模**是非常重要的；

**时序图和协作图**都是描述系统动态视图的交互图，

**生命线**是UML视图中**时序图的组成部分**；

**状态图**描述一个对象的生命周期，

**协作图强调**收发消息的对象的空间结构。

### 正向工程和逆向工程

正向：先生成UML，再开发软件

逆向：先开发软件，再生成UML

