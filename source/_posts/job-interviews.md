---
title: 面试题
date: 2023-09-10 22:23:32
author: 橙子草
tags:
- 面试
category:
- 后端
top_img: https://pic.imgdb.cn/item/64f49295661c6c8e541915d8.webp
cover: https://pic.imgdb.cn/item/64f49295661c6c8e541915d8.webp
---

## 记录一下各类面试八股文

### Java

{% folding  , List、Set、Map三者的区别? %}

- List（对付顺序的好帮手）： List 接口存储一组不唯一（可以有多个元素引用相同的对象）、有序的对象。

- Set（注重独一无二的性质）：不允许重复的集合，不会有多个元素引用相同的对象。

- Map（用Key来搜索的专业户）: 使用键值对存储。Map 会维护与 Key 有关联的值。两个 Key可以引用相同的对象，但 Key 不能重复，典型的 Key 是String类型，但也可以是任何对象。

{% endfolding %}



### Spring

{% folding  , 讲一下什么是Spirng？ %}

- Spring是一个轻量级的IoC和AOP容器框架。是为Java应用程序提供基础性服务的一套框架，目的是用于简化企业应用程序的开发。Spring的核心思想是通过依赖注入和面向切面编程来实现松耦合、可测试和易维护的应用程序
Spring框架提供了许多核心功能，包括

**控制反转(Inversion of Control, IoC)** ：

> 讲对象的创建和依赖关系的管理交给框架来完成，使得应用程序更加松耦合

**依赖注入(Dependency Injection, DI)** ：

> 将对象之间的依赖关系通过注入的方式来实现，提高了应用程序的可测试性和可维护性

**面向切面编程(Aspect-Oriented Programming, AOP)** ：

> 通过切面来解决横切关注点的问题，如事务控制、安全控制、日志记录等

**数据访问层(Data Access)** ：

> 提供了一套方便的API来访问数据库和其他数据存储系统，包括JDBC、ORM、NoSQL等

**Web开发(Web Development)** ：

> 提供了一套强大的Web开发框架，包括Spring MVC、Spring WebFlux等

**消息队列(Messaging)** ：

> 提供了一套消息传递机制，支持JMC、RabbitMQ等
除此之外，Spring还提供了许多其他功能，如集成测试、批处理、缓存等。

{% endfolding %}



{% folding  , 依赖注入的方式有几种，各是什么? %}

- 依赖注入(Dependence Injection)是一种设计模式，它的主要思想是通过构造器、Setter方法或接口来向对象传递依赖关系，而不是让对象自己创建或查找依赖对象。在Spring框架中，依赖注入是实现松耦合、可测试和易维护的重要手段，通常有以下几种方式

  1. **构造器注入(Constructor Injection)：**

     通过对象的构造器来注入依赖对象，通常在对象创建时就完成了依赖注入

     ```JAVA
     // 使用构造器注入方式，将UserRepository类型的依赖项注入到UserService中
     public class UserService {
     
         private UserRepository userRepository;
     
         public UserService(UserRepository userRepository) {
             this.userRepository = userRepository;
         }
     
         // ...
     }
     ```

     ```XML
     <bean id="userRepository" class="com.example.UserRepositoryImpl" />
     
     <bean id="userService" class="com.example.UserService">
         <constructor-arg ref="userRepository" />
     </bean>
     ```

  2. **Setter方法注入(Setter Injection)：**

     通过对象的Setter方法来注入依赖对象，通常在对象创建后进行依赖注入

     ```JAVA
     public class UserService {
     
         private UserRepository userRepository;
     
         public void setUserRepository(UserRepository userRepository) {
             this.userRepository = userRepository;
         }
     
         // ...
     }
     ```

     ```XML
     <bean id="userRepository" class="com.example.UserRepositoryImpl" />
     
     <bean id="userService" class="com.example.UserService">
         <property name="userRepository" ref="userRepository" />
     </bean>
     ```

  3. **接口注入(Interface Injection)：**依赖类必须要实现指定的接口，然后实现该接口中的一个函数，该函数就是用于依赖注入。该函数的参数就是要注入的对象。侵入性太强，不建议使用

{% endfolding %}


{% folding , 谈谈你对Spring的AOP的理解 %}

- **AOP(Aspect-Oriented Programming, 面向切面编程)**是Spring框架的一个核心特性之一，它通过在程序运行期间动态地将额外的行为(例如日志、安全检查等)插入到代码中，以实现更加灵活和可维护的程序设计
- 在Spring框架中，AOP主要通过以下几个概念来实现
  1. **切点(Pointcut)** ：指定在哪些程序执行点上插入额外的行为，通常使用表达式来定义切点
  2. **通知(Advice)** ：插入到切点上的额外行为，通常包括前置通知、后置通知、异常通知、环绕通知等
  3. **切面(Aspect)** ：由切点和通知组成第一个横切逻辑单元，可以看做是一种特殊的类
  4. **织入(Weaving)** ：将切面与目标对象合并，生成一个新的代理对象，并在运行期间插入额外行为
- 在Spring框架中，AOP可以应用于各种场景，如事务管理、缓存、日志、权限控制等，可以大大简化程序设计和代码维护工作，同时Spring框架还提供了各种AOP相关的注解和工具类，使得AOP的使用变得更加简单和方便

{% endfolding %}



{% folding , 说说你对Spring的IoC是怎么理解的 %}

- Spring的IOC(Inversion of Control)是指将对对象的创建、组装、管理的责任交给容器，由容器负责对象之间的依赖关系。在IOC模式中，对象不再自己管理其他对象的依赖，而是将依赖关系反转给容器进行管理
- 在Spring中，IOC是通过依赖注入(Dependency Injection, DI)实现的，依赖注入是指容器通过自动或者手动的方式，将对象所依赖的其他对象或者资源注入到对象中，从而达到对象之间的松耦合。
- 通过使用IOC容器，可以实现对象之间的解耦，增加代码的灵活性和可维护性。同时IOC容器也提供了很多功能，例如对象的生命周期管理、AOP、事务管理等，可以大大减少开发者的工作量，提高开发效率
- 总的来说，Spring的IOC是通过依赖注入实现的，将对象之间的依赖关系交给容器进行管理，从而实现对象之间的松耦合和增强系统的可维护性和可扩展性

{% endfolding %}

### Myabatis



{% folding , 什么是MyBatis？ %}

- MyBatis是一款基于Java的持久层框架，它提供了一种简单的方式来映射数据库操作到Java对象。它内部封装了JDBC，开发时只需要关注SQL语句本身，不需要花费精力去处理加载驱动、创建连接、创建statement等繁杂的过程。程序员直接编写原生态SQL，可以严格控制SQL执行性能，灵活度高
- MyBatis可以使用XML或注解来配置映射原生信息，将POJO映射成数据库中的记录，避免了几乎所有JDBC代码和手动设置参数以获取结果集
- 通过XML文件或注解的方式将要执行的各种statement配置起来，并通过Java对象和statement中的SQL的动态参数进行映射生成最终执行的SQL语句，最后由MyBatis框架执行SQL并将结果映射为Java对象并返回

{% endfolding %}



{% folding ,说说MyBatis的优点和缺点 %}

- 优点
  1. 基于SQL语句编程，相当灵活，不会对应用程序或数据库的现有设计造成任何影响，SQL写在XML里，解除SQL与程序代码的耦合（用注解写就另说了），便于统一管理；提供XML标签，支持编写动态SQL语句，并可重用
  2. 与JDBC相比，减少了50%以上的代码量，消除了JDBC大量冗余的代码，不需要手动开关连接
  3. 提供应设标签，支持对象与数据库的ORM字段关系映射，提供对象关系映射标签，支持对象关系组件维护
- 缺点
  1. SQL语句编写的工作量较大，尤其当字段多、关联表多时，对开发人员编写SQL语句的功底有一定要求
  2. SQL语句依赖于数据库，导致数据库移植性差，不能随意更换数据库
  3. XML配置较为繁琐，MyBatis的配置文件中需要编写大量的XML代码来描述SQL语句和映射关系，这可能会使配置文件显得较为繁琐

{% endfolding %}



{% folding , #{} 和 ${} 的区别是什么？ %}

- 在MyBatis中，**#{}**和**${}**都是用来表示参数占位符的。不过它们的使用方式略有不同
  - **#{}** 在SQL语句中表示一个占位符，它可以防止SQL注入攻击，并且可以自动进行参数类型转换。在执行SQL语句时，MyBatis会将参数值以安全的方式设置到SQL语句中。底层使用的是 **PreparedStatement** ，**#{} **占位符替换为 **?**
  - **${}** 在SQL语句中也表示一个占位符，但它不会对参数进行任何处理，直接将参数值拼接到SQL语句中，因此容易引发SQL注入攻击。底层使用的是 **Statement**

{% endfolding %}



### Mysql



{% folding ,介绍一下数据库三范式 %}

数据库三范式（Third Normal Form，3NF）是关系数据库设计中的一种规范化原则，旨在消除数据冗余和数据插入、更新和删除异常。它是基于关系数据库理论的一种设计方法。

三范式的规则如下：

1. 第一范式（1NF）：确保每个列都是原子的，即每个列中的值都是不可再分的。这意味着每个列都只包含一个值。

2. 第二范式（2NF）：在满足第一范式的基础上，确保表中的非主键列完全依赖于主键列。换句话说，每个非主键列都必须完全依赖于主键，而不能依赖于主键的一部分。

3. 第三范式（3NF）：在满足第二范式的基础上，确保表中的非主键列之间没有传递依赖关系。换句话说，任何非主键列都不能依赖于其他非主键列。

通过遵循三范式，可以减少数据冗余，提高数据存储效率，并减少数据插入、更新和删除时的异常情况。然而，严格遵循三范式也可能导致查询时需要进行多表连接，从而影响查询性能。因此，在实际设计中，需要根据具体情况权衡范式的遵循程度。

{% endfolding %}



{% folding ,介绍一下数据库事务 %}

数据库事务（Database Transaction）是指由一系列数据库操作组成的逻辑单位，这些操作要么全部执行成功，要么全部回滚到事务开始前的状态，保证数据库的一致性和完整性。

事务具有以下四个特性（ACID特性）：

1. 原子性（Atomicity）：事务中的所有操作要么全部执行成功，要么全部失败回滚。如果事务中的任何一步操作失败，整个事务都将被回滚到最初状态，不会对数据库造成任何影响。

2. 一致性（Consistency）：事务执行前后，数据库必须保持一致性状态。这意味着事务中的操作必须满足数据库定义的所有约束和规则，不会破坏数据的完整性。

3. 隔离性（Isolation）：事务的执行是相互隔离的，即一个事务的操作不会对其他事务造成影响。每个事务都应该感觉到它是在独立的环境中运行，并且对其他事务是不可见的，直到它被提交。

4. 持久性（Durability）：一旦事务被提交，其结果将永久保存在数据库中，即使发生系统故障或崩溃。数据库系统必须能够将事务的结果持久化到磁盘或其他非易失性存储介质中。

事务的使用可以确保数据库操作的一致性和完整性，同时也能提供并发控制和错误恢复机制。在实际应用中，需要根据业务需求和性能要求来合理地使用事务，避免长时间的事务阻塞其他操作和过多的事务回滚。

{% endfolding %}



{% folding ,SQL优化手段有哪些? %}

SQL优化是指对数据库中的SQL语句进行调整和优化，以提高查询和修改数据的效率，下面是一些常用的SQL优化手段

1. 查询语句中不要使用**SELECT** ：使用**SELECT * **会查询出所有的列，包括可能不需要的列，这样会增加查询的数据量，影响查询的效率。在实际应用中，应该尽量指定需要查询的列。

   ```SQL
   # 优化前
   SELECT * FROM user;
   
   # 优化后
   SELECT id, name, age FROM user;
   ```

2. 尽量减少子查询，使用关联查询(**LEFT JOIN**、**RIGHT JOIN**、**INNER JOIN**)替代：子查询是指在一个查询语句中嵌套另一个查询语句。由于子查询需要进行多次查询，因此会降低查询的效率。可以使用关联查询来替代子查询，以减少查询次数。

   ```SQL
   # 优化前
   SELECT name, age, (SELECT MAX(salary) FROM salary WHERE salary.user_id = user.id) AS max_salary FROM user;
   
   # 优化后
   SELECT user.name user.age MAX(salary.salary) AS max_salary
   FROM user
   LEFT JOIN salary ON user.id = salary.user_id
   GROUP BY user.id, user.name, user.age;
   ```

3. 减少使用**IN**或**NOT IN**，使用**EXISTS**、**NOT EXISTS**或关联查询替代：**IN**和**NOT IN**查询会对列表中的每个值进行匹配，因此查询效率较低。可以使用**EXISTS**或**NOT EXISTS**查询语句或关联查询语句替代

   ```SQL
   # 优化前
   SELECT name FROM user WHERE id IN (SELECT user_id FROM order WHERE status = 'completed')
   # 优化后
   SELECT name FROM user
   WHERE EXISTS (SELECT 1 FROM order WHERE order.user_id - user.id AND order.status = 'completed')
   ```

4. **OR**的查询尽量使用**UNION**和**UNION ALL**代替（在确认没有重复数据或不用去重数据时，UNION ALL会更好）：**OR**查询语句会对多个条件进行匹配，而**UNION**和**UNION ALL**查询语句会将多个查询语句的结果合并。在确定没有重复数据或不需要剔除重复数据时，使用**UNION ALL**会比**UNION**更高效。

   ```SQL
   # 优化前
   SELECT * FROM table WHERE condition1 OR condition2 OR condition3;
   # 优化后
   SELECT * FROM table WHERE condition1
   UNION ALL
   SELECT * FROM table WHERE condition2
   UNION ALL
   SELECT * FROM table WHERE condition3;
   ```

5. 尽量避免在**WHERE**子句中使用 **!=** 、 **<>** 操作符，否则引擎将放弃使用索引而进行全表扫描，可以使用**=**操作符或**NOT**操作符来替代

   ```SQL
   # 优化前
   SELECT name FROM user WHERE age <> 18;
   # 优化后
   SELECT name FROM user WHERE age < 18 OR age > 18;
   ```

6. 尽量避免在**WHERE**子句中对字段进行NULL值判断，否则将导致引擎放弃使用索引而进行全表扫描，如

   ```SQL
   SELECT id FROM tb WHERE id IS NULL
   # 改为如下形式，前提是num设置默认值为0，确保num列不会出现NULL值
   SELECT id FROM tb WHERE id = 0
   ```

{% endfolding %}



{% folding ,什么是内连接、左外连接、右外链接? %}

- 内连接(Inner Join)：匹配两张表中相关联的记录
- 左外连接(Left Outer Join)：除了匹配两张表中相关联的记录外，还会匹配左表中剩余的记录，右表中未匹配到的字段用NULL表示
- 右外链接(Right Outer Join)：除了匹配两张表中相关联的记录歪，还会匹配右表中剩余的记录，左表中未匹配到的字段用NULL表示

{% endfolding %}



{% folding ,什么是视图? %}

视图（View）是在关系数据库中的一种虚拟表，它是通过查询语句定义的，由一个或多个基本表的行和列组成。视图并不实际存储数据，而是根据定义的查询语句动态生成结果集。

视图可以理解为对表的一种逻辑上的封装，它提供了一种以不同方式组织和呈现数据的方式，隐藏了底层表的复杂性。通过视图，可以实现以下功能：

1. 简化数据访问：视图可以定义复杂的查询语句，隐藏了底层表的结构和关系，简化了数据访问的复杂性。
2. 数据安全性：通过视图，可以限制用户对数据的访问权限。可以根据需要控制用户只能访问特定的列或行，保护敏感数据的安全性。
3. 数据统一性：通过视图，可以将多个表中的数据以一种统一的方式呈现，简化了数据的查询和分析操作。
4. 数据完整性：通过视图，可以定义数据的完整性约束，确保数据的一致性和有效性。

视图在数据库中的使用非常广泛，可以提高数据的可用性、安全性和灵活性。通过定义不同的视图，可以根据不同用户或应用程序的需求提供定制化的数据访问方式。

{% endfolding %}



{% folding ,说说悲观锁和乐观锁? %}

悲观锁（Pessimistic Locking）和乐观锁（Optimistic Locking）是并发控制的两种常见策略，用于处理多个用户同时访问数据库时可能出现的数据冲突问题。

悲观锁：

> - 悲观锁的策略是假设在整个事务过程中会有其他用户对同一数据进行修改，因此在访问数据之前就会对其进行加锁，阻止其他用户对数据的修改。
> - 当一个用户对数据进行修改时，其他用户需要等待锁的释放才能继续操作。
> - 悲观锁通常使用数据库的锁机制来实现，如行级锁或表级锁。
> - 悲观锁适用于并发写入操作较多的场景，可以保证数据的一致性和完整性。

乐观锁：
> - 乐观锁的策略是假设在整个事务过程中不会有其他用户对同一数据进行修改，因此不会对数据进行加锁。
> - 当一个用户对数据进行修改时，会检查在读取数据后是否有其他用户对数据进行了修改。如果有修改，则会回滚事务并重新尝试操作。
> - 乐观锁通常使用版本号或时间戳等机制来实现，每个数据记录都有一个标识来表示当前的版本。
> - 乐观锁适用于并发读取操作较多的场景，可以提高系统的并发性能。

选择悲观锁还是乐观锁取决于具体的业务需求和并发访问模式。悲观锁可以保证数据的一致性，但会降低并发性能；乐观锁可以提高并发性能，但可能需要进行重试操作以处理数据冲突。在实际应用中，需要根据具体情况选择适合的并发控制策略。

{% endfolding %}



### SpringBoot

{% folding ,为什么要用SpringBoot？ %}

- 因为SpringBoot的优点非常多
  1. 独立运行：SpringBoot内嵌了各种servlet容器，如Tomcat、Jetty等，现在不再需要打成war包部署到容器中，SpringBoot只要打成一个可执行的jar包就能独立运行，所有的依赖包都在一个jar包内
  2. 简化配置：SpringBoot提供了很多starter依赖，可以快速集成其他框架和组件，大大简化了配置过程。
  3. 自动配置：SpringBoot的自动配置非常强大，可以根据类路径下的jar包、类文件和注解来自动配置bean，减少了手动配置的工作量。
  4. 无代码生成和XML配置：SpringBoot使用条件注解和自动配置来完成所有的配置工作，避免了代码生成和繁琐的XML配置文件，让开发更加简洁、清晰。
  5. 应用监控：SpringBoot提供了很多有用的端点和指标，可以用来监控和管理应用程序，包括健康检查、性能监控、日志查看等。此外，SpringBoot还可以与Actuator集成，提供更加丰富的监控功能。

{% endfolding %}

{% folding ,SpringBoot的核心注解是哪个？它主要由哪几个注解组成的？ %}

- SpringBoot的核心注解是**@SpringBootApplication**，它主要是由三个注解组成，分别是
  1. **@Configuration**：声明当前类是一个配置类
  2. **@EnableAutoConfiguration**：开启SpringBoot的自动配置功能
  3. **@ComponentScan**：开启组件扫描，会自动扫描当前包及其子包下的所有类，并注册为Spring的Bean
- 这三个注解组合在一起，可以让SpringBoot自动配置并启动应用程序。除此之外，SpringBoot还有很多其他注解，如**@RestController**、**@Service**、**@Repository**等，它们可以帮助我们更方便地创建控制器、服务层、数据访问层等组件

{% endfolding %}



{% folding ,如何使用SpringBoot实现异常处理？ %}

- 在SpringBoot中，可以使用 **@ControllerAdvice** 注解定义一个全局异常处理器，来统一处理应用程序中的异常，具体实现步骤如下

  1. 定义一个异常处理类，并使用 **@ControllerAdvice** 注解来标注，例如

     ```JAVA
     @ControllerAdvice
     public class GlobalExceptionHandler {
     
         @ExceptionHanlder(value = Exception.class)
         public ResponseEntity<String> handleException(Exception e){
             // 处理异常，并返回合适的HTTP响应
         }
     }
     ```

  2. 在处理方法中定义 **@ExceptionHandler** 注解，指定需要处理的异常类型。可以使用多个 **@ExceptionHandler** 注解定义不同的处理方法来处理不同类型的异常

  3. 处理异常，并返回合适的HTTP响应，可以返回一个自定义的错误信息、一个HTTP错误码，或者其他合适的响应

{% endfolding %}



### Redis

{% folding ,什么是Redis？ %}

- Redis是一个高性能的内存数据存储系统，也可以称为键值存储系统。它支持多种数据结构，包括字符串、哈希、列表、集合、有序集合等，还提供了一些高级功能，如发布订阅、事务、Lua脚本等。Redis的特点是数据存储在内存中，可以快速读写，同时支持数据持久化到磁盘中。Redis还具有分布式特性，可以通过分片和赋值来实现高可用和高扩展性。
- Redis主要应用于缓存、会话存储、消息队列、排行榜等场景，具有快速、稳定、可靠等优点。由于其出色的性能和易用性，Redis已经成为最受欢迎的内存数据库之一。

{% endfolding %}

{% folding ,使用Redis有哪些好处？ %}

- 使用Redis有以下几个好处
  1. 高性能：Redis将数据存储在内存中，读写速度非常快，可以达到几十万甚至上百万QPS，特别适合高并发场景。
  2. 数据结构丰富：Redis支持多种数据结构，如字符串、哈希、列表、集合、有序集合等，可以满足不同场景下的需求。
  3. 持久化：Redis支持将数据持久化到磁盘中，以保证数据的安全性和可恢复性。
  4. 分布式特性：Redis支持分片和复制，可以实现高可用和高扩展性，支持数据在多台服务器之间的共享。
  5. 丰富的功能：Redis提供了许多高级功能，如事务、Lua脚本、发布订阅、过期策略等，可以满足更加复杂的业务需求。

{% endfolding %}



{% folding ,Redis常见性能问题和解决方案有哪些？ %}

1. 网络延迟：Redis的性能很大程度上受限于网络延迟，因此需要尽可能减少网络传输次数和数据量，避免过多的网络IO操作
   - 解决方案：可以使用Redis的Pipline特性，将多个请求打包发送，减少网络传输的次数；也可以使用Redis的批量操作命令，将多个数据一次性提交，减少网络传输的数据量。
2. 大量的数据读写：Redis的单线程模型会在高并发读写的情况下出现性能瓶颈，导致响应时间变长。
   - 解决方案：可以使用Redis的主从复制和集群特性，将数据分布在多个节点上，增加系统的读写并发能力。
3. 慢查询：当Redis中存在大量慢查询操作时，会影响Redis的整体性能。
   - 解决方案：可以使用Redis的slowlog功能，记录Redis的慢查询操作，并使用Redis的监控工具进行监控，及时发现慢查询问题。
4. 内存使用过多：Redis需要将所有的数据存储在内存中，当数据量过大时，会占用大量的内存资源，导致Redis的性能下降。
   - 解决方案：可以使用Redis的持久化功能，将数据写入磁盘中，以释放内存空间；也可以使用Redis的内存优化技巧，如删除不必要的数据、合理使用Redis的数据结构等。
5. 阻塞操作：当Redis执行某些操作时，会阻塞其他操作的执行，从而影响Redis的整体性能。
   - 解决方案：可以使用Redis的异步操作特性，将阻塞操作转化为异步操作，以提高Redis的性能和吞吐量。

{% endfolding %}



{% folding ,缓存雪崩、缓存穿透、缓存预热、缓存更新、缓存降级都了解吗？ %}

- 简述其概念如下
  1. 缓存雪崩：指在某个时间段内缓存集体过期失效或缓存服务重启，导致大量请求都落到数据库上，从而导致数据库崩溃的情况。
  2. 缓存穿透：指查询一个不存在的数据，由于缓存没有命中，导致所有的请求都会到数据库上，造成数据库压力过大，严重的可能会导致数据库宕机。
  3. 缓存预热：指系统上线后，将相关的缓存数据直接加载到缓存系统中，避免在用户请求过程中因没有预先加载而导致缓存穿透的现象。
  4. 缓存更新：指对数据库中的数据更新时，同时更新缓存中的数据，保证缓存数据和数据库的一致性。
  5. 缓存降级：指在缓存失效或缓存访问异常时，为了保证系统的可用性，通过一些机制，将请求转发到其他服务或者直接返回默认值，从而避免系统崩溃或者因为缓存故障导致业务受损。
- 常见的Redis缓存降级策略包括：
  1. 熔断降级：当Redis缓存故障或者超时时，系统会进入熔断状态，所有请求奖杯转发到备用服务或者直接返回默认值。
  2. 限流降级：当Redis缓存无法处理所有请求时，系统会采用限流策略，限制访问流量，保护系统资源，避免系统崩溃。
  3. 数据降级：当Redis缓存故障时，系统可以返回默认值，避免因缓存故障导致业务受损。

{% endfolding %}



{% folding ,介绍一下缓存穿透，缓存雪崩，缓存击穿以及解决方案？ %}

缓存穿透、缓存雪崩和缓存击穿是常见的缓存相关的问题，它们可能导致缓存系统的性能下降或无法正常工作。以下是对这些问题的简要介绍以及相应的解决方案：



1. 缓存穿透（Cache Penetration）：缓存穿透指的是对于一个不存在于缓存中的数据的请求，每次请求都会直接访问数据库。这可能导致数据库的负载过大，缓存系统无法发挥作用。

> 解决方案：
>
> - 使用布隆过滤器（Bloom Filter）来过滤掉不存在的数据，减少对数据库的访问。
> - 在缓存中设置空值（Null Value）或者缓存空对象，避免频繁查询数据库。



2. 缓存雪崩（Cache Avalanche）：缓存雪崩指的是缓存中大量的数据同时失效，导致所有的请求都直接访问数据库。这会导致数据库压力骤增，系统性能下降。

> 解决方案：
>
> - 设置缓存数据的过期时间时，尽量将过期时间分散开，避免大量数据同时失效。
> - 使用热点数据预加载，提前将热点数据加载到缓存中，避免在同一时间大量请求访问数据库。



3. 缓存击穿（Cache Breakdown）：缓存击穿指的是对于一个热点数据的请求，缓存中的数据过期后，大量的请求同时访问数据库。这会导致数据库压力骤增，系统性能下降。

> 解决方案：
>
> - 设置热点数据的永久缓存，避免数据过期后导致的缓存击穿问题。
> - 使用互斥锁（Mutex Lock）或分布式锁来控制只有一个请求能够访问数据库，并在数据库查询完数据后更新缓存。



总的来说，为了解决缓存穿透、缓存雪崩和缓存击穿问题，可以采取多种手段，如布隆过滤器、缓存预加载、合理设置过期时间、永久缓存热点数据和使用锁机制等。根据具体的业务场景和需求，选择合适的解决方案可以有效地提高缓存系统的性能和可靠性。

{% endfolding %}



{% folding ,Redis的数据类型，以及每种数据类型的使用场景？ %}

- 常见的几种数据类型和使用场景如下：
  1. 字符串(String)：字符串类型是Redis最基本的数据结构，一个键最大能存储512MB。
     - 使用场景：适用于计数器、分布式锁、缓存等常见。
  2. 列表(List)：列表是链表结构，可以在头部和尾部添加元素。
     - 使用场景：可以做简单的消息队列功能。利用Irange命令，做基于Redis的分页功能。
  3. 集合(Set)：集合是通过哈希表实现的无序集合，每个元素都是独一无二的。
     - 使用场景：适用于好友关系、共同好友等去重和计算交集、并集、差集的场景。
  4. 哈希(Hash)：哈希结构类似于关联数组，由字段和值组成。
     - 使用场景：适用于对象缓存。
  5. 有序集合(Sorted Set)：有序集合类似于集合，不同的是每个元素都会关联一个权重(score)，按照权重进行排序。
     - 使用场景：排行榜、带权重的任务队列等场景。
  6. 位图(BitMap)：用于存储二进制位的数据结构，可以进行位运算，支持高效的位图计算。
     - 使用场景：用户签到记录。
  7. 地理位置(Geo)：用于存储地理位置信息的数据结构。
     - 使用场景：附近的酒店、餐厅。
  8. HyperLogLog：用于进行基数计数的数据结构，支持高效的对大量元素进行去重统计。
     - 使用场景：网站的UV统计。

{% endfolding %}



{% folding ,为什么Redis的操作是原子性的，怎么保证原子性？ %}

- Redis的操作是原子性的，是因为Redis是单线程的。在Redis中，所有的操作都是以单线程的方式执行的，这意味着在同一时刻只会有一个操作在执行，不会发生并发的情况。

- Redis保证原子性的方式主要有两种：事务和Lua脚本。

  > - 在事务中，Redis会将多个命令打包成一个事务进行执行，事务中的所有命令都会在一次操作中被执行，要么全部执行成功，要么全部不执行。而Lua脚本则可以将多个操作打包成一个原子性的操作进行执行，这个操作要么全部执行成功，要么全部不执行。另外，Redis还提供了一些原子性操作，例如INCR、DECR等，这些操作都是原子性的。
  > - 在并发环境下，如果多个线程同时执行get和set命令，可能会出现竞争条件，从而导致数据不一致的问题。但是如果使用Redis提供的原子性操作INCR，则不会存在这种问题，因为INCR命令是原子性的。
  > - 因此可以使用Redis事务或者Redis+Lua的方式保证多个命令在并发中的原子性，或者使用Redis提供的原子性操作。

通过以上的机制，Redis可以保证操作的原子性，确保每个操作的完整性和一致性。这对于一些需要保证数据一致性和可靠性的场景非常重要。

{% endfolding %}

### SpringCloud

{% folding ,什么是微服务？ %}

- 微服务是一种架构风格，它将一个大型应用程序拆分成一组小型、自治的服务，每个服务都运行在自己的进程中，通过轻量级的通信机制来相互协作，以达到高度灵活、可伸缩、可维护和可测试的目的。
- 每个服务都可以独立地开发、部署和扩展，并且可以使用不同的编程语言和技术栈来实现。微服务架构的核心思想是将应用程序按照业务功能划分出一组小的服务，每个服务都有自己的数据存储和业务逻辑，而服务之间通过网络通信协作完成整个应用的功能。

{% endfolding %}



{% folding ,SpringCloud有哪些常用组件？ %}

Spring Cloud是一个用于构建分布式系统的开发工具集，它提供了一系列的组件和模块，常用的组件包括：

1. Eureka：服务注册与发现组件，用于实现服务的自动注册与发现。
2. Ribbon：客户端负载均衡组件，用于实现服务之间的负载均衡。
3. Feign：声明式的HTTP客户端组件，用于简化服务之间的调用。
4. Hystrix：容错管理组件，用于实现服务的熔断、降级和限流。
5. Zuul：API网关组件，用于实现统一的访问入口和路由规则。
6. Config：配置管理组件，用于实现分布式配置的集中化管理。
7. Bus：消息总线组件，用于实现配置的动态刷新。
8. Sleuth：分布式追踪系统，用于实现请求链路的跟踪和监控。
9. Stream：消息驱动组件，用于实现消息的发布和订阅。
10. Security：安全认证和授权组件，用于实现服务的安全管理。

除了以上常用组件，Spring Cloud还提供了一些其他的组件和模块，如Spring Cloud Alibaba、Spring Cloud Consul等，可以根据具体的需求选择使用。

{% endfolding %}



{% folding ,SpringBoot和SpringCloud的区别？ %}

- SpringBoot和SpringCloud都是基于Spring Framework的框架。SpringBoot主要关注于快速构建单体应用程序，而SpringCloud主要关注构建分布式系统的基础设施和提供微服务开发的解决方案。
- 具体来说，二者的区别如下
  1. 目标不同：SpringBoot旨在简化单体应用的构建，而SpringCloud旨在构建分布式系统的基础设施和微服务
  2. 功能不同：SpringBoot提供了一系列开箱即用的功能，如自动配置、内嵌Tomcat、SpringMVC、SpringData、SpringSecurity等；而SpringCloud则提供了一些分布式系统的基础设施和微服务解决方案，如服务注册与发现、配置中心、负载均衡、断路器、消息总线等
  3. 使用方式不同：SpringBoo是一个单体应用框架，开发者可以使用期快速构建单体应用，而SpringCloud则是一个基础设施框架，需要在SpringBoot的基础上进行集成和使用
- 总的来说，SpringBoot和SpringCloud都是SpringFramework的扩展和增强，但是在目标、功能和使用方式等方面有所不同。在开发分布式系统好微服务时，通常需要同时使用SpringBoot和SpringCloud

{% endfolding %}



{% folding ,什么是服务降级、服务熔断、服务隔离？ %}

- 服务降级、服务熔断、服务隔离都是为服务架构中常见的容错机制，用于保证系统的稳定性和可靠性
- 服务降级是指当下系统出现异常或负载过高时，通过调整系统的运行策略，优先保证系统的核心功能，而暂时关闭非核心或者低优先级的功能，从而减轻系统负担，保证系统的可用性。
- 服务熔断是指当系统出现异常或负载过高时，通过关闭对一些服务的访问，从而避免不断地请求导致系统崩溃，从而保证系统的稳定性。同时，熔断器还提供了快速失败的响应，避免客户端长时间等待导致系统响应时间变慢
- 服务隔离是指将不同的服务部署在不同的容器中，通过限制每个服务的资源使用，避免由于某个服务的异常或者负载过高，导致整个系统奔溃，从而保证系统的可用性和稳定性。

{% endfolding %}



{% folding ,SpringCloud有什么优势？ %}

Spring Cloud具有以下优势：

1. 简化分布式系统开发：Spring Cloud提供了一系列的组件和工具，能够帮助开发人员快速构建分布式系统。它提供了服务注册与发现、负载均衡、容错管理、配置管理等功能，大大简化了分布式系统的开发和部署过程。

2. 易于集成和扩展：Spring Cloud基于Spring框架，与Spring Boot无缝集成，可以与各种开发框架和第三方组件进行集成。同时，Spring Cloud还提供了丰富的扩展点和API，可以根据实际需求进行定制和扩展。

3. 提供了完整的解决方案：Spring Cloud提供了一整套的解决方案，包括服务注册与发现、负载均衡、容错管理、配置管理、API网关等，可以满足大部分分布式系统的需求。开发人员可以根据实际需求选择合适的组件和模块，构建出稳定可靠的分布式系统。

4. 社区活跃：Spring Cloud是由Spring社区开发和维护的，拥有庞大的用户群体和活跃的社区。开发人员可以通过社区获取最新的技术动态、解决方案和问题答疑，提高开发效率和质量。

5. 易于部署和管理：Spring Cloud基于微服务架构，每个服务都是独立部署和管理的，可以根据需求进行水平扩展和容器化部署。同时，Spring Cloud还提供了配置管理、监控和追踪等工具，方便系统的运维和管理。

总的来说，Spring Cloud提供了一套完整的分布式系统解决方案，具有简化开发、易于集成和扩展、社区活跃等优势，能够帮助开发人员构建高效、稳定和可扩展的分布式系统。

{% endfolding %}



{% folding ,什么是Nacos？ %}

Nacos是一个开源的服务发现、配置管理和服务管理平台，是阿里巴巴开源的一个重要组件，也是Spring Cloud Alibaba生态圈的核心组件之一。

Nacos可以提供服务注册与发现、配置管理、动态路由、流量管理等功能，是构建云原生应用的重要基础设施。它支持多种服务注册和发现方式，包括基于DNS和HTTP的服务发现，能够自动管理服务实例的注册和注销。同时，Nacos还提供了配置管理功能，可以实现动态配置的集中化管理，支持配置的动态刷新和版本管理。

Nacos的特点包括：

1. 服务注册与发现：Nacos提供了服务注册和发现功能，能够自动管理服务实例的注册和注销，支持多种服务注册和发现方式。

2. 配置管理：Nacos支持配置的集中化管理，可以实现动态配置的加载和刷新，支持配置的版本管理和回滚。

3. 动态路由：Nacos可以实现动态路由，支持基于服务的动态路由和流量管理，可以根据实际需求进行灵活的路由配置。

4. 服务管理：Nacos提供了服务的健康检查和故障切换功能，能够自动监测服务的健康状态，并进行故障切换和容错处理。

5. 高可用和扩展性：Nacos支持集群部署和自动扩展，能够提供高可用的服务注册、配置和管理功能。

总的来说，Nacos是一个功能强大、易于使用和高可用的服务发现、配置管理和服务管理平台，能够帮助开发人员构建可靠、可扩展的分布式系统。在Spring Cloud Alibaba生态圈中，Nacos被广泛应用于服务注册和发现、配置管理等方面。

{% endfolding %}



{% folding ,Ribbon的作用？ %}

Ribbon是一个客户端负载均衡组件，它是Spring Cloud中的一个重要组件之一。

Ribbon的主要作用是实现服务之间的负载均衡，即将客户端请求均匀地分发到多个服务实例上，从而提高系统的可用性和性能。具体来说，Ribbon可以实现以下功能：

1. 服务实例的选择：Ribbon会从服务注册中心获取可用的服务实例列表，并根据一定的负载均衡策略选择合适的服务实例。

2. 请求的分发：当客户端发起请求时，Ribbon会将请求分发到被选中的服务实例上，实现请求的负载均衡。

3. 重试和容错：Ribbon支持请求的重试和容错处理，当某个服务实例不可用时，Ribbon会自动选择其他可用的实例进行重试或容错处理。

4. 动态配置：Ribbon支持动态配置，可以通过配置中心实时更新负载均衡策略和服务实例列表，实现动态的负载均衡。

通过使用Ribbon，开发人员可以很方便地实现服务之间的负载均衡，提高系统的可用性和性能。在Spring Cloud中，Ribbon通常与Eureka等组件配合使用，实现服务的自动发现和负载均衡。

{% endfolding %}



{% folding ,Feign的作用？ %}

- Feign是一个声明式、模块化的HTTP客户端，它可以让开发者更加方便地调用HTTP API。在SpringCloud微服务架构中，Feign通常用于简化服务间的HTTP调用，并且与Ribbon负载均衡结合使用，提供更加稳定和高效的服务调用
- 使用Feign时，只需要定义一个接口，然后使用注解来描述接口中的方法和参数。Feign会根据这些注解自动构建出HTTP请求，并且处理响应结果。这样就避免了手动构建HTTP请求的麻烦，并且可以提高代码的可读性和可维护性
- Feign的主要作用有
  1. 简化服务间的HTTP调用，提高开发效率
  2. 集成了Ribbon负载均衡，提供更加稳定和高效的服务调用
  3. 可以自动将HTTP请求转换为Java方法调用，并将响应结果转换为Java对象
  4. 支持自定义解码器、拦截器、错误处理等功能，具有良好的扩展性
- 总之，Feign是一个非常实用的HTTP客户端库，在SpringCloud微服务架构中具有重要的作用，可以简化服务间的HTTP调用，提高开发效率和代码质量

{% endfolding %}





{% folding ,什么是服务降级、服务熔断、服务隔离？ %}

- 服务降级、服务熔断、服务隔离都是为服务架构中常见的容错机制，用于保证系统的稳定性和可靠性
- 服务降级是指当下系统出现异常或负载过高时，通过调整系统的运行策略，优先保证系统的核心功能，而暂时关闭非核心或者低优先级的功能，从而减轻系统负担，保证系统的可用性。
- 服务熔断是指当系统出现异常或负载过高时，通过关闭对一些服务的访问，从而避免不断地请求导致系统崩溃，从而保证系统的稳定性。同时，熔断器还提供了快速失败的响应，避免客户端长时间等待导致系统响应时间变慢
- 服务隔离是指将不同的服务部署在不同的容器中，通过限制每个服务的资源使用，避免由于某个服务的异常或者负载过高，导致整个系统奔溃，从而保证系统的可用性和稳定性。

{% endfolding %}
